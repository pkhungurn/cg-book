<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/theme.css" rel="stylesheet">
  <!-- MathJax -->
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        tags: "ams",
      },
      svg: {
        fontCache: 'global'
      },
    };
  </script>
  <script type="text/javascript" id="MathJax-script" src="../mathjax/tex-mml-chtml.js"></script>
  <link rel="stylesheet"
      href="../highlight/styles/default.min.css">
  <script src="../highlight/highlight.min.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script>
  hljs.highlightAll();
  hljs.initLineNumbersOnLoad();
  </script>
    
  <title>Chapter 12</title>
</head>

<body>
  <div class="container" style="max-width: 640px;">
    <span style="visibility: hidden;">
      \(
      \def\sc#1{\dosc#1\csod}
      \def\dosc#1#2\csod{{\rm #1{\small #2}}}

      \newcommand{\dee}{\mathrm{d}}
      \newcommand{\Dee}{\mathrm{D}}
      \newcommand{\In}{\mathrm{in}}
      \newcommand{\Out}{\mathrm{out}}
      \newcommand{\pdf}{\mathrm{pdf}}
      \newcommand{\Cov}{\mathrm{Cov}}
      \newcommand{\Var}{\mathrm{Var}}

      \newcommand{\ve}[1]{\mathbf{#1}}
      \newcommand{\mrm}[1]{\mathrm{#1}}
      \newcommand{\ves}[1]{\boldsymbol{#1}}
      \newcommand{\etal}{{et~al.}}
      \newcommand{\sphere}{\mathbb{S}^2}
      \newcommand{\modeint}{\mathcal{M}}
      \newcommand{\azimint}{\mathcal{N}}
      \newcommand{\ra}{\rightarrow}
      \newcommand{\mcal}[1]{\mathcal{#1}}
      \newcommand{\X}{\mathcal{X}}
      \newcommand{\Y}{\mathcal{Y}}
      \newcommand{\Z}{\mathcal{Z}}
      \newcommand{\x}{\mathbf{x}}
      \newcommand{\y}{\mathbf{y}}
      \newcommand{\z}{\mathbf{z}}
      \newcommand{\tr}{\mathrm{tr}}
      \newcommand{\sgn}{\mathrm{sgn}}
      \newcommand{\diag}{\mathrm{diag}}
      \newcommand{\Real}{\mathbb{R}}
      \newcommand{\sseq}{\subseteq}
      \newcommand{\ov}[1]{\overline{#1}}
      \DeclareMathOperator*{\argmax}{arg\,max}
      \DeclareMathOperator*{\argmin}{arg\,min}
      \)
    </span>

    <h1>12 &nbsp; Uniform variables</h1>
    <hr>

    <p>In this last chapter, we saw examples on how vertex shaders can be used to render more complex shapes by transforming simple shapes. One thing that should become clear is that a GLSL program can only transform shapes that are passed to them through vertex and index buffers. The data that are to be stored in these buffers are prepared first by the Javascript part of our application, which we shall call the <b>host program</b>. They are then stored in the computer's main memory (i.e., RAM). Then, the host program transfers the data to the buffers, which reside in GPU memory. As a result, communication between the host program and the GLSL program is a crucial part of 3D application development with OpenGL.</p>

    <p>So far, we have been using only one mechanism for communication between a host program and a GLSL program: buffers. Buffers are specialized for communicating vertex and index data, and they have many restrictions. GLSL programs do not have direct access to data inside index buffers. A vertex shader can access data inside vertex buffers, but a fragment shader cannot. However, there are two more such mechanisms: uniform variables and textures. This chapter discuss the former, but the reader would have to wait until Chapter XXX for a discussion of the latter.</p>

    <p>A <b>uniform variable</b> is a piece of GPU memory for storing a small piece of information, which can be directly set by the host program. Unlike buffers, both vertex shaders and fragment shaders have access to uniform variables. Both shaders would see the same value when referencing the same uniform variable, and this is why it is called "uniform." Moreover, the shaders cannot change the value themselves, so this value would remain constant until the host program rewrites the variable. As a result, uniform variables can serve as "global" variables for GLSL programs.</p>

    <p>In this chapter, we will how to declare and manipulate uniform variables with both GLSL and Javascript. We start with a simple program where uniform variables are used to communicate user inputs to GLSL programs. We will then see how to manipulate uniform variables so that they change with time, and this would allow use to create simple animations. We will then study uniform variables that have <code>struct</code> type, which allow us to systematically manage related variables.</p>

    <h2>12.1 &nbsp; Program 1: Basic usage of uniform variables</h2>

    <p>Program 1's source code is available in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-12/program-01"><tt>chapter-12/program-01</tt></a> directory of the code repository. Its screenshots are shown in Figure 12.1.</p>

    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-01-screenshot-00.png"><img src="images/program-01-screenshot-00.png" alt="" width="200"></a></td>
          <td><a href="images/program-01-screenshot-01.png"><img src="images/program-01-screenshot-01.png" alt="" width="200"></a></td>
          <td><a href="images/program-01-screenshot-02.png"><img src="images/program-01-screenshot-02.png" alt="" width="200"></a></td>
        </tr>
        <tr>
          <td align="center">(a)</td>
          <td align="center">(b)</td>
          <td align="center">(c)</td>
        </tr>
      </table
      <figcaption class="figure-caption"><strong>Figure 12.1</strong> Screenshots of Program 1 (a) when it is started afresh (b) when the color sliders are manipulated, and (c) when the "phase," "peroid," and "amplitude" sliders are manipulated.</figcaption>
    </figure>

    <p>Program 1 draws a sine curve on its canvas. The curve's color and shape can be control by the 6 sliders in the web page. The first three sliders are used to pick the RGB color of the sine curve. The next three sliders control the phase, period, and amplitude of the curve, respectively.</p>

    <p>Recall that this is not the first time we control what appears on the screen with UI elements. In Program 4 of Chapter 8, we control the color of the canvas through sliders. Moreover, just in the last chapter, we choose what shapes appear in canvases through radio boxes. However, the mechanism used to change the canvas in these programs do not require any information to be passed from the host program to the GLSL shader. In Program 4 of Chapter 8, we use the slider values as arguments to <code>gl.clearColor</code>, a Javascript method. In the last chapters, we use the radio boxes' values to choose which GLSL program to use, and this process is carried out entirely in Javascript. In this chapter, though, we explicitly pass information from UI elements (i.e., the sliders) to the GLSL program, and let the program process the information itself.</p>

    <h3>12.1.1 &nbsp; Declaring and using uniform variables in GLSL</h3>

    <p>As said earlier, the mechanism we use to pass information from host to GLSL in this chapter is the uniform variable. Let's see first hand how they are declared and used in the shaders of our program. We will start with the easier one, the fragment shader, whose source code is reproduced in full below.</p>

<pre><code class="language-c">#version 300 es

precision highp float;

out vec4 fragColor;

uniform vec3 color;

void main() {
    fragColor = vec4(color, 1.0);
}</code></pre>

    <p>The code above is very similar to those of the fragment shaders in the last chapter. There are two main differences. The first is that there is a new variable called <code>color</code> declared with the <code>uniform</code> keyword.</p>

<pre><code class="language-c">uniform vec3 color;</code></pre>

    <p>As you may guess, this is the uniform variable in question. It is just a variable declared with the keyword <code>uniform</code> in front of the data type of the variable. One important thing to note is that a uniform variable <b>must be declared outside any functions</b>. This makes sense because a uniform variable is supposed to be a global variable that should be accessible from any functions. So, its scope should be the entire program, not just inside a particular function. However, remember that a uniform variable is read only, so one should not assign any value to it. In our fragment shader, we use the RGB values stored in the <code>color</code> variable to fill the first 3 components of the output fragment color.</p>

    <p>Next, we look at the vertex shader, which is a little more complicated because it has three uniform variables instead of one.</p>

<pre><code class="language-c">#version 300 es

const float PI = 3.14159265359;

in float t;

uniform float amplitude;
uniform float period;
uniform float phase;

void main() {
    float x = t;
    float y = amplitude * sin(2.0 * PI * t /period + phase);
    gl_Position = vec4(x, y, 0.0, 1.0);    
}</code></pre>

    <p>We can see creates a sine curve by plotting points $(x,y)$ where
    \begin{align*}
      x &= t, \\
      y &= \mathrm{amplitude} \times \sin\bigg(\frac{2\pi t}{\mathrm{period}} + \mathrm{phase}\bigg).
    \end{align*}
    Here the <code>amplitude</code>, <code>period</code>, and <code>phase</code> variables are uniform variables whose types are <code>float</code>. The names of the variables speak for themselves. The <code>amplitude</code> controls how tall the sine curve is. The <code>period</code> controls with width of one copy of the sine wave. Lastly, the <code>phase</code> controls the horizontal position of where a copy of the sine curve begins.
    </p>

    <h3>12.1.2 &nbsp; Manipulating uniform variables in Javascript</h3>

    <p>It is not enough to modify the GLSL code to declare and use uniform variables. We must change our Javascript code so that it becomes aware of them and assign their values. The code that manipulates uniform variables is in the <a href="https://github.com/pkhungurn/cg-book-code/blob/d06742a0902d97fd738fbc969a2e2c0f077338f3/chapter-12/program-01/src/index.js#L72"><code>updateWebGL</code></a> method in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-12/program-01/src/index.js"><code>index.js</code></a> file. Let us start with how to assign a value to the <code>amplitude</code> uniform variable. The first thing we do is to fetch the value to assign from a slider.</p>

<pre><code class="language-c">let amplitude = this.amplitudeSlider.slider("value") / 1000.0;</code></pre>

    <p>Here, the <code>amplitudeSlider</code> is a JQuery UI slider that was prepared in the <a href="https://github.com/pkhungurn/cg-book-code/blob/d06742a0902d97fd738fbc969a2e2c0f077338f3/chapter-12/program-01/src/index.js#L21"><code>createUi</code></a> method. How the slider came about is not important as the important thing is that we need a way to figure out what to assign to the uniform variable.</p>

    <p>Before we can assign a value to a uniform variable, we need to use the GLSL program that the uniform variable is a part of. So, next part of the <code>updateWebGL</code> method looks like the following.</p>

<pre><code class="language-c">useProgram(this.gl, this.program, () => {
  //
  // Assigning values to uniform variables.
  //

  setupVertexAttribute(
    self.gl, self.program, "t", self.vertexBuffer, 1, 4, 0);
  drawElements(
    self.gl, self.indexBuffer, self.gl.LINES, (self.numVertices-1)*2, 0);
});</code></pre>

    <p>We see that the code uses the <code>useProgram</code> function that we learned about in <a href="../chapter-09/index.html#resource-management">Section 9.4.1</a>. All the manipulation of the uniform variables are done inside the closure that we give the <code>useProgram</code> function as an input. Moreover, notice that the segment that assign uniform variable comes before the last two statements, which draw primitives. This makes sense because uniform variables can affect the shape and appearance of the primitives being drawn, so we must assign them before drawing.</p>

    <p>The segment that assigns values to uniform variables is quite long because we have four variables (<code>rgb</code>, <code>amplitude</code>, <code>period</code>, and <code>phase</code>) to take care of. However, assigning a uniform variable only involves two lines of code. We reproduce the piece of code that assigns the <code>amplitude</code> variable below.</p>

<pre><code class="language-c">// ******************
// * Using uniforms *
// ******************
// Step 1: Get its location.
let amplitudeLocation = self.gl.getUniformLocation(self.program, "amplitude");
// Step 2: Set its value using the right function.
self.gl.uniform1f(amplitudeLocation, amplitude);
</code></pre>

    <p>Assigning value to a uniform variable involves two steps. The first is to find the "location" of the uniform variable. Here, a location is just a unique identifier that can be used to refer to the variable at a later time. It can be fetched by the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getUniformLocation"><code>getUniformLocation</code></a> method of the WebGL context. The method requires two inputs. The first is the object representing the GLSL program that contains the uniform variable, and the second is the name of the variable as declared in either the vertex and/or fragment shader.</p>

    <p>The second step is to assign the value with a method of the WebGL context whose name is of the form <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform"><code>uniformXXX</code></a> where <code>XXX</code> depends on the type of the uniform variable in question. For non-array types, the rule for the name is quite simple. <code>XXX</code> has two characters.</p>

    <ul>
      <li>The first character is either <code>1</code>, <code>2</code>, <code>3</code>, or <code>4</code>, and it indicates how many numbers the data type can store.</li>
      <li>The second character is either <code>i</code> or <code>f</code>, and it indicates the type of each number stored in the data type: <code>i</code> is for integer, and <code>f</code> is for floating point.</li>
    </ul>

    <p>As a result, the right methods to use for a number of types of uniform variables are as follows.</p>

    <figure>
      <table class="table table-bordered" style="border-color: black">
        <tr>
          <td><b>Uniform variable type</b></td>
          <td><b>Element type</b></td>
          <td><b>Number of elements</b></td>
          <td><b>Method name</b></td>
        </tr>
        <tr>
          <td><code>int</code></td>
          <td><code>int</code></td>
          <td>1</td>
          <td><code>uniform1i</code></td>
        </tr>
        <tr>
          <td><code>ivec2</code></td>
          <td><code>int</code></td>
          <td>2</td>
          <td><code>uniform2i</code></td>
        </tr>
        <tr>
          <td><code>ivec3</code></td>
          <td><code>int</code></td>
          <td>3</td>
          <td><code>uniform3i</code></td>
        </tr>
        <tr>
          <td><code>int</code></td>
          <td><code>int</code></td>
          <td>4</td>
          <td><code>uniform4i</code></td>
        </tr>
        <tr>
          <td><code>float</code></td>
          <td><code>float</code></td>
          <td>1</td>
          <td><code>uniform1f</code></td>
      </tr>
      <tr>
        <td><code>vec2</code></td>
        <td><code>float</code></td>
        <td>2</td>
        <td><code>uniform2f</code></td>
      </tr>
      <tr>
        <td><code>vec3</code></td>
        <td><code>float</code></td>
        <td>3</td>
        <td><code>uniform3f</code></td>
      </tr>
      <tr>
        <td><code>vec4</code></td>
        <td><code>float</code></td>
        <td>4</td>
        <td><code>uniform4f</code></td>
      </tr>
      </table>
      <figcaption class="figure-caption"><strong>Table 12.1</strong> Names of the <code>uniformXXX</code> method to be used for certain types of uniform variables.</figcaption>
    </figure>


    <p>In our case, the <code>amplitude</code> uniform variable is of type <code>float</code>, which means the type can only hold one floating point number. Thus, the appropriate method to use is <code>uniform1f</code>. This method takes two arguments. The first is the location of the uniform variable, which we just fetched in the last step, and the second is the floating point value we want to assign.</p>

    <p>Because the <code>period</code> and <code>phase</code> uniform variables are also of type <code>float</code>, we deal with these variables the same way we deal with <code>amplitude</code>.</p>

<pre><code class="language-c">let periodLocation = self.gl.getUniformLocation(self.program, "period");
self.gl.uniform1f(periodLocation, period);

let phaseLocation = self.gl.getUniformLocation(self.program, "phase");
self.gl.uniform1f(phaseLocation, phase);
</code></pre>

    <p>We deal with the <code>color</code> uniform variable slightly differently because it is of type <code>vec3</code> instead of <code>float</code>. As <code>vec3</code> stores 3 floating point numbers, the WebGL context method used to assign its value is <code>uniform3f</code> instead of <code>uniform1f</code>.</p>

<pre><code class="language-c">let colorLocation = self.gl.getUniformLocation(self.program, "color");
self.gl.uniform3f(colorLocation, color[0], color[1], color[2]);
</code></pre>

    <p>We can see that <code>uniform3f</code> takes 4 parameters instead of 2. The first parameter is still the location of the uniform variable, but 3 floating point values have to be supplied instead of 1. Here, we feed the three values in the <code>color</code> array that was prepared earlier in the <code>updateWebGL</code> function.</p>

<pre><code class="language-c">let color = this.rgbSliders.map(s => s.slider("value") / 255);</code></pre>

    <p>This line of code computes the <code>color</code> array by applying the closure that extracts the slider value and divides it by $255$ to the three sliders that correspond to the R, G, and B values that the user can specify.</p>

    <p>There are 6 other methods in Table 12.1 that we have not seen actual usage. However, their usage follows the same rule that applies to <code>uniform1f</code> and <code>uniform3f</code>. The first argument is the location of the uniform variable. The method then takes $N$ extra arguments where $N$ is the number in the method name, and these are arguments are the values to be assigned to the components of the uniform variable.</p>

    <h2>12.2 &nbsp; Program 2: Using a uniform variable to create a moving square</h2>

    <p>In this section, we are going to study another important way to use uniform variables: animation. This principle is simple. We can use Javascript to keep track of how much time have passed since our program started. Then, we can use this information to change how primitives are rendered. This is done by passing the time or other information derived from it to GLSL programs. This section's program renders a square moving in a circular path at a constant angular speed. This source code of the program is available in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-12/program-02"><code>chapter-12/program-02</code></a> directory of the book's Github repository. Screenshots of the program are available below.</p>
  
    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-02-screenshot-00.png"><img src="images/program-02-screenshot-00.png" alt="" width="300"></a></td>
          <td><a href="images/program-02-screenshot-01.png"><img src="images/program-02-screenshot-01.png" alt="" width="300"></a></td>
        </tr>        
      </table>
      <figcaption class="figure-caption"><strong>Figure 12.2</strong> Screenshots of Program 2. The square moves in a circular path.</figcaption>
    </figure>

    <a name="time-tracking"></a>
    <h3>12.2.1 &nbsp; How to keep track of time</h3>

    <p>An animation is an image that moves. This means that it changes with time. Creating animation thus requires us to draw different images at different time. As a r esult, a program that creates an animation must be aware of time. In our case, we need to keep track of how much time has passed since the program begins because the exact time (say, 10:10AM) does not matter.</p>

    <p>We keep track of time through the use of the method <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now</code> in the host Javascript code.</a> Here, <code>performance</code> is a global variable that comes with the Javascript language. The <code>now</code> method takes no arguments and returns the number of milliseconds since a time which is always before our Javascript program starts. The program has an infinite loop that keeps calling the <code>updateWebGL</code> method in order to repeatedly draw something on the WebGL canvas. As a result, if we call <code>performance.now</code> inside the <code>updateWebGL</code>, we can easily know the time (since the start time) that each interation of the loop is run.</p>

    <p>As stated earlier, we will not use the time directly, but we will keep track of how much time has passed since the program started. To do so, we keep track of the last time the <code>updateWebGL</code> was called. This is stored in the <code>lastTime</code> field of the <code>WebGLApp</code> object that represents our application. We initialize the field in the constructor as follows.</p>

<pre><code class="language-c">this.lastTime = performance.now();</code></pre>

    <p>When an instance of <code>WebGLApp</code> is constructed, its <code>updateWebGL</code> method has not been called yet. As a result, we set <code>lastTime</code> field to a time returned from <code>performance.now</code> to get an arbitrary starting point. This point in time is not exactly where the program starts, but it should be pretty close. <p>We use another field called <code>elaspedTime</code> to store the time since the <code>lastTime</code> field was initialized. We initialize the field to $0$.</p>

    <p>Inside the <code>updateWebGL</code> method, we need to update both fields so that <code>elapsedTime</code> has the correct value. The code to do so is as follows.</p>
    
<pre><code class="language-c">let currentTime = performance.now();
let delta = currentTime - this.lastTime;   
this.elaspedTime += delta;
this.lastTime = currentTime;
</code></pre>

    <p>The logic of the above code is quite simple. We call <code>performance.now</code> to get the current time. We then subtract from it the <code>lastTime</code> field to get the number of milliseconds since last time the <code>updateWebGL</code> method was called. We add this value to the <code>elapsedTime</code> field to update its value. Then, we set the <code>lastTime</code> field to the current time so that we can use this value in the next iteration. The <code>elapsedTime</code> field now stores the number of milliseconds since the program starts, and it gets updated every time the <code>updateWebGL</code> method is executed.</p>

    <a name="time-dependent-displacement"></a>
    <h3>12.2.2 &nbsp; Time-dependent displacement</h3>

    <p>One of the simplest form of animation is when an object continuously moves withouth changing its shape. The animation Program 2 shows is exactly this: a white square that moves in a circular path. To move is to change position. A <b>displacement</b> is a vector that represents a change in position. It is defined as:
    \begin{align*}
      \mathrm{displacement} = (\mathrm{new\ position}) - (\mathrm{old\ position}).
    \end{align*}
    Now, an object in our context is a mesh. A mesh is a collection of vertices that are connected together. Each vertex has a position, and it is stored in the mesh's vertex buffer. We often think of these positions as the vertices' "rest position" as they are the positions that define the shape of the object when it is not move or deformed. To move an object without changing its shape, we just have to move all vertices by the same displacement. In this way, all the relative distances between the vertices will be preserved. Mathematically, this is done by adding the displacement to the position of each vertex, and this is exactly what is done in the vertex shader of Program 2.
    </p>

<pre><code class="language-c">#version 300 es

in vec2 vert_position;

uniform vec2 displacement;

void main() {
    gl_Position = vec4(vert_position + displacement, 0, 1);
}</code></pre>

    <p>Much like many GLSL programs have seen before, we use the <code>vert_position</code> attribute variable to store vertex positions. What is new is the <code>displacement</code> uniform variable, which represents the displacement. We can see that what the vertex shader does is to add the displacement to the vertex position and output the result.</p>

    <p>Now that we know how to move an object from its rest position to another position, we now need to figure out how to make the object's position change over time. This is easy: we only need to make the displacement changes over time. So, every time the screen is update, we need to set the <code>displacement</code> uniform variable to a new value. Let's look at the part of the <a href="https://github.com/pkhungurn/cg-book-code/blob/d334f114da0f590cb4c04e200604e45979a0e706/chapter-12/program-02/src/index.js#L45"><code>updateWebGL</code></a> method that does this.</p>

<pre><code class="language-c">let angularPosition = 0.001 * this.elaspedTime;
        
let displacementX = 0.5 * Math.cos(angularPosition);
let displacementY = 0.5 * Math.sin(angularPosition);

useProgram(this.gl, this.program, () => {
  let displacementLocation = self.gl.getUniformLocation(
    self.program, "displacement");
  self.gl.uniform2f(
    displacementLocation, displacementX, displacementY);
  
    :
    :
    :
});</code></pre>

    <p>Because we want our square to move in a circular path, the displacement should be vectors from the center of a circle to points on the circumference of the circle. In case of unit circles, the vectors are given by
    \begin{align*}
      \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} \cos \theta \\ \sin \theta \end{bmatrix}
    \end{align*}
    where $\theta$ is an angle. As a result, we can our square to move in a circular path by changing the angle over time. This is basically what the Javascript code do in this code line:    
    </p>

<pre><code class="language-c">let angularPosition = 0.001 * this.elaspedTime;</code></pre>

    <p>Here, <code>angularPosition</code> is the variable we use to represent the angle. As discussed in the last section, the field <code>elapsedTime</code> changes every time the <code>updateWebGL</code> method is called. The factor <code>0.001</code> is applied because <code>elapsedTime</code>'s unit is milliseconds, which means that using the value directly would make the square move 1 radian (about one sixth of a circle) per millisecond, which is too fast for our naked eyes to see. From <code>angularPosition</code>, the code computes the $x$- and $y$-componets of the displacement with:
    \begin{align*}
      \begin{bmatrix}
        \mathrm{displacementX} \\ \mathrm{displacementY}
      \end{bmatrix}
      &= \begin{bmatrix}
        0.5 \cos(\mathrm{angularPosition}) \\
        0.5 \sin(\mathrm{angularPosition}) 
      \end{bmatrix}.
    \end{align*}
    The number $0.5$ here is the radius of the circle we want our square to move on. Because the canvas corresponds to the rectangle $[-1,1] \times [-1,1]$, choosing the radius of $0.5$ will make the square's path fit inside the screen.
    </p>

    <p>Lastly, after the $x$- and $y$-components have been computed, we set the uniform variable <code>displacement</code> to these values with <code>glUniform2f</code>.</p>

<pre><code class="language-c">let displacementLocation = self.gl.getUniformLocation(
  self.program, "displacement");
self.gl.uniform2f(
  displacementLocation, displacementX, displacementY);
</code></pre>

    <h2>12.3 &nbsp; Program 3: Using uniform variables to animate a boucing ball</h2>

    <p>In the last section, we animate a rotating square that does not move, so we will create a more sophisticated animation in this section: one that involves a ball bouncing around the canvas. The source code of the program is availble in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-12/program-03"></a><code>chapter-12/program3</code> directory of the book's Github repository. Once you run the program, you will see a white circle moving along straight line paths and changing direction when it hits any one of the side of the screen.</p>

    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-03-screenshot-00.png"><img src="images/program-03-screenshot-00.png" alt="" width="200"></a></td>
          <td><a href="images/program-03-screenshot-01.png"><img src="images/program-03-screenshot-01.png" alt="" width="200"></a></td>
          <td><a href="images/program-03-screenshot-02.png"><img src="images/program-03-screenshot-02.png" alt="" width="200"></a></td>
        </tr>
        <tr>
          <td align="center">(a)</td>
          <td align="center">(b)</td>
          <td align="center">(c)</td>
        </tr>
      </table
      <figcaption class="figure-caption"><strong>Figure 12.3</strong> Screenshots of Program 3, showing a circular ball moving through the screen.</figcaption>
    </figure>

    <h3>12.3.1 &nbsp; Drawing a circle</h3>

    <p>The animation in this section is more advanced that that in the last section because of two reasons. The first is that the movement is more complex: the ball moves and bounces of walls instead of rotating in place. The second is that the shape is more complex: a circle instead of a square. We shall deal with the shape in this section.</p>

    <p>You may recall that we have written a program that draw a circle before in the last chapter. However, we will usea different method here. The idea is to approximate a circle with a collection of triangles. We call such a triangle a "slice," much like a slice of pizza or a slice of pie.  Each slice has two of its vertices on the circumference of the circle, and the circle's center serves as the third vertex.</p>

    <figure class="figure">
      <b>TODO: Create this figure.</b>
      <figcaption class="figure-caption"><strong>Figure 12.4</strong> How to approximate a circle by breaking it down to triangular slices.</figcaption>
    </figure>    

    <p>You can see that the more slices we have, the more rounded our approximated circle will seem to the viewer. Here, we set the number of slices to 128 in the constructure of the <code>WebGLApp</code> class, and this is quite enough for the ball of radius $0.1$ that we will be drawing.</p>

<pre class="language-c"><code>this.numSlices = 128;
this.radius = 0.1;
</code></pre>

    <p>We need to write the <code>createBuffers</code> method, which creates the vertex and index buffers to be used later in the rendering loop. This means that we have to think about these vertices' positions and how they are ordered inside a vertex buffer. To allow ourselves to change the circle's radius if we so desire, we will create the vertex buffer so that it represents a circle of radius $1$ instead of $0.1$, and we will resize the circle inside the vertex shader.</p>
      
    <p>Because there are 128 slices, there will be 128 vertices that are on the circumference of the circle. Then, there is another vertex which is at the center, so there are 129 vertices in total. We should arrange their positions inside a vertex buffer so that it becomes easier to construct the index buffer later. The author found that packing the vertices on the circumference as the first 128 vertices (Verticex #0 to #127) and putting the center as the last vertex (Vertex #128) makes index buffer construction easy. For the first 128 vertices, the $i$th vertex should have position 
    $$ \mbox{position of the $i$th vertex of circle of radius $1$} = \begin{bmatrix}  \cos ( 2\pi i / 128) \\ \sin (2\pi i / 128)  \end{bmatrix}$$ 
    where $r$ is the radius of the circle. What are seeing here is that we are dividing the $2\pi$ complete angles into 128 intervarls, and this gives us 128 angles at the beginning of each intervals: $\frac{2\pi\times 0}{128}$, $\frac{2\pi\times 1}{128}$, $\dotsc$, $\frac{2\pi \times 127}{128}$. We then insert a vertex at each of these angles to the vertex buffer as done in the code below, which is located inside the <code>createBuffers</code> function.</p>

<pre class="language-c"><code>let vertexData = [];
for(let i=0; i&lt;this.numSlices; i++) {
    let angle = 2 * Math.PI * i / this.numSlices;
    vertexData.push(
      this.radius * Math.cos(angle), this.radius * Math.sin(angle));
}  
</code></pre>

    <p>Then, we insert the circle's center $(0,0)$ at the end.</p>

<pre class="language-c"><code>vertexData.push(0.0);
vertexData.push(0.0);
</code>
</pre>

    <p>We can now specify the index buffer. Because each primitive is a triangle, we add three vertex indices at a time. Because there are 128 triangles, we do that 128 times. For the $i$th triangle, we use two adjacent vertices on the circumference&mdash;Vertex $i$ and $(i+1) \% 128$&mdash;and then add the center, Vertex 128.</p>

<pre class="language-c"><code>let indexData = [];
for(let i=0; i&lt;this.numSlices; i++) {
    indexData.push(i);
    indexData.push((i+1) % this.numSlices);
    indexData.push(this.numSlices);
}
this.indexBuffer = createIndexBuffer(this.gl, new Int32Array(indexData));</code></pre>

    <p>It's important that the second index we add is $(i+1) \% 128$ rather than $i+1$. This is because we cause we want the last slice&mdash;when $i=127$&mdash; to loop back to the first vertex. More specifically, it should use Vertex 127 and then Vertex 0. Adding 1 and then modulo by 128 accomplishes this.</p>

    <p>Our vertex and index buffers are now complete. Nevertheless, they represent a circle of radius $1$ centered at $(0,0)$. However, what we want to render is a circle of radius $0.1$ that moves around the screen. How do we actually accomplish this? Notice that there are two problems here. The first is that the circle is too large, and the second is that it is fixed in space. To solve the first problem, we just have to realize that if we multiply all the vertex positions by $r$, the circle becomes $r$ times larger/smaller, which means it becomes the circle of radius $r$ centered at $(0,0)$.
    \begin{align*}
    &\mbox{vertex of circle of radius $r$ centered at $(0,0)$} \\
    &= r \times \Big(\mbox{vertex of circle of radius $1$ centered at $(0,0)$}\Big).
    \end{align*}
    To solve the second problem, we use what we learned in the last section. If we want the circle to move around the screen, we just have to move all of its vertex by the same amount of "displacement." More specifically, we need to add a 2D displacement vector $\ve{d}$ to all vertex positions, and the circle will be centered at point $\ve{d}$ instead of $(0,0)$.
    \begin{align*}
    &\mbox{vertex of circle of radius $r$ centered at $\ve{d}$} \\
    &= \mbox{vertex of circle of radius $r$ centered at $(0,0)$} + \ve{d} \\ 
    &= r \times \Big(\mbox{vertex of circle of radius $1$ centered at $(0,0)$}\Big) + \ve{d}.
    \end{align*}
    </p>

    <p>We write the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-12/program-03/src/vertex-shader.vert">vertex shader</a> to carry out the last equation above. To do this, we need two uniform varibles, one to store the radius of the circle, and the other to store the displacement applied to all vertices.</p>

<pre><code class="language-c">#version 300 es

in vec2 vert_position;

uniform vec2 displacement;
uniform float radius;

void main() {
    gl_Position = vec4(radius * vert_position + displacement, 0, 1);
}</code></pre>

    <p>To draw the moving ball, we need to figure out how to set the <code>displacement</code> uniform variable, which is the subject of the next section.</p>
    
    <h3>12.3.2 &nbsp; Animating a bouncing ball</h3>

    <p>A bouncing ball moves in a straight line until it hits one of the borders of the screen. At that point, it changes direction and continues moving in that direction. So, in order to program our bouncing ball, we need to be able to do three things.</p>

    <ol>
      <li>Make the ball move in a straight line.</li>
      <li>Detect when the ball hits a wall.</li>
      <li>Change the ball's direction once it hits a wall.</li>
    </ol>

    <p>Let's first deal with how to make a ball move in a straight line. From physics, the rate at which a particle moves in a straight line is called its <b>velocity</b>, and it is typically denoted by a vector $\ve{v}$. Let us say that, at the time $t_{\mrm{last}}$, the particle was at position $\ve{p}_{\mrm{last}}$. Moreover, from time $t_{\mrm{last}}$, time has advanced to $t_{\mrm{current}}$. Then, the position of the ball at $t_{\mrm{current}}$ would be given by $$p_{\mrm{current}} = p_{\mrm{last}} + (t_{\mrm{current}} - t_{\mrm{last}}) \ve{v} = p_{\mrm{last}} + \Delta t \times \ve{v}.$$ Here, $\Delta t$ stands for $t_{\mrm{current}} - t_{\mrm{last}}$.</p>

    <p>Note that we have learned how to keep track of time in Section <a href="#time-tracking">12.2.1</a>, and we shall use the code of Program 2 again in Program 3 for convenience. In particular, in the <code>updateWebGL</code> method, we have access to the variable <code>delta</code>, which stores the amount of time between $t_{\mrm{last}}$, the last time <code>updateWebGL</code> was called, and $t_{\mrm{current}}$, the current time.</p>

    <p>Next, we need to think about how to keep track of the ball's position as this will change over time. Here, we shall say that the ball's position is the position of its center, which is the displacement vector $\ve{d}$ in the last section. So, quite counterintuitively, we store the position of the ball in the following two variables defined in the constructor of Program 3.</p>

<pre><code class="language-c">this.displacementX = 0.0;
this.displacementY = 0.0;</code></pre>

<!--<p>The variables are called "<code>displacement</code>" rather than "<code>position</code>." There are two reasons for naming them this way. The first is that, recall from Setion 1 that $$\mbox{displacement} = (\mbox{new position}) - (\mbox{old position}).$$ If "old position" is $(0,0)$, then it follows that $$\mbox{displacement} = \mbox{new position}.$$ So, for simplicity of Program 3, we simply say that the position of the ball at the start of the program is $(0,0)$. This means that its position any time afterwards is equal to its displacement with respect to $(0,0)$. The second reason is that this displacement can be thought of as the displacement to be applied to the positions of the vertices of the circle defined in the last section, much like the displacement we applied to the vertices of the square in Section <a href="#time-dependent-displacement">12.2.2</a>. It is quite commmon in computer graphics programming to interchange position with displacement.</p>
-->

    <p>We also need variables to keep track of the ball's velocity because it changes over time as well. Again, these variables are defined and initialized in the constructor as follow.</p>

<pre><code class="language-c">let angle = 2 * Math.PI * Math.random();
this.velocityX = Math.cos(angle) * 0.001;
this.velocityY = Math.sin(angle) * 0.001;</code></pre>

    <p>The first thing that the piece of code above does is to generate a random angle from the interval $[0, 2\pi)$. This angle is used to determined the direction of our vector. Because we randomize the direction, you will see that the ball moves differently every time you refresh the browser.  The velocity itself is defined in the two lines below where we set the <code>velocityX</code> and <code>velocityY</code> fields to the cosine and the sine of the angle, respectively, times $0.001$. Recall that we also used $0.001$ in Program 2 to account for the fact that time in our programs have the unit of milliseconds.</p>

    <p>Now that we have variables and fields to store every relevant piece of information, we are ready to make the ball move by updaing its position. Recall from physics that
    \begin{align*}
      \mbox{velocity} = \frac{\mbox{displacemet}}{\mbox{time}} = \frac{(\mbox{new position}) - (\mbox{old position})}{\mbox{time}}.
    \end{align*}
    As a result,
    \begin{align*}
      \mbox{new position} = (\mbox{old position}) + \mbox{time} \times velocity. 
    \end{align*}
    As a result, the first thing we do is to update the ball's position (confusingly represented by the fields <code>displacementX</code> and <code>displacementY</code>) according to the above equation. The piece of code that does this is in the <code>updateWebGL</code> method and is reproduced below.
    </p>

<pre><code class="language-c">this.displacementX = this.displacementX + delta * this.velocityX;
this.displacementY = this.displacementY + delta * this.velocityY;
</code></pre>

    <p>The code above will make the ball move along a straight line along the direction of the velocity vector. However, this is not the end of the story because, if it continues doing that, the ball will go out of the frame and become invisible afterwards. We instead want the ball to bounces off the screen's border. To do so, we must check when the ball touches a border, force it to stay inside the screen, and change its velocity.</p>

    <p>So, how do we check for when the ball hits a border? Let's consider the right screen border, which is the line $x = 1$. The ball hits the right border if any part of it, especially its rightmost part, is to the right of the line $x = 1$. Recall that the ball's position is the position of its center, and the ball's position is stored in the <code>displacementX</code> and <code>displacementY</code> field. So, the $x$-position of the ball's rightmost part is given by
    \begin{align*}
      \mbox{$x$-position of the ball's rightmost part} = \texttt{displacementX} + \mbox{radius}
    \end{align*}
    So, the ball hits the right border if the $x$-position of its rightmost part is greater than $1$:
    \begin{align*}
      \texttt{displacementX} + \mbox{radius} > 1.
    \end{align*}
    In other words,
    \begin{align*}
      \texttt{displacementX} > 1 - \mbox{radius}.
    \end{align*}
    As a result, we can check for this condition and do the necessary updates. This is done by the <code>if</code> statement below.
    </p>

<pre><code class="language-c">if (this.displacementX > 1.0 - this.radius) {
  :
  :
}</code></pre>
    
    <p>The next thing to figure out is what updates we want to perform when the ball hits the right wall; i.e., what the code should we right inside the <code>if</code> clause. First, when the ball hits the well, part of it is already outside the screen, and we don't want that. So, the first thing to do is to keep the call inside the screen. This is quite easy. We just set the ball's $x$-position to that of the moment it "touches" the wall but not going over it.</p>

<pre><code class="language-c">this.displacementX = 1.0 - this.radius;
</code></pre>

    <p>The next thing is to change the ball's velocity so that, instead of moving to the right, the ball would move to the left. This can be done simply by negating the $x$-component of the velocity vector.</p>

<pre><code class="language-c">this.velocityX *= -1.0;</code></pre>

    <p>Putting the updates and the checks for wall collision togther, we have the following code that deals with collision with the right wall.</p>

<pre><code class="language-c">if (this.displacementX > 1.0 - this.radius) {
  this.displacementX = 1.0 - this.radius;
  this.velocityX *= -1.0;
}</code></pre>

    <p>We are done with the right wall, but there are 3 more walls left. The <code>updateWebGL</code> method contains three more if statements that deal with the left wall, the top wall, and the bottom wall. They call if the same structure: check if the ball is over the wall, keep the ball inside the wall, and negate the relevant component of the velocity to make the ball move in the opposite direction.</p>

<pre><code class="language-c">if (this.displacementX < -1.0 + this.radius) {
  this.displacementX = -1.0 + this.radius;
  this.velocityX *= -1.0;
}
if (this.displacementY > 1.0 - this.radius) {
  this.displacementY = 1.0 - this.radius;
  this.velocityY *= -1.0;
}if (this.displacementY < -1.0 + this.radius) {
  this.displacementY = -1.0 + this.radius;
  this.velocityY *= -1.0;
}
</code></pre>

    <p>Now that we have updated the ball's position and dealt with collision against the walls, we can render the moving ball by setting the uniform variables to the right values as folllows.</p>

<pre><code class="language-c">useProgram(this.gl, this.program, () => {
  let displacementLocation = self.gl.getUniformLocation(self.program, "displacement");
  self.gl.uniform2f(displacementLocation, this.displacementX, this.displacementY);

  let radiusLocation = self.gl.getUniformLocation(self.program, "radius");
  self.gl.uniform1f(radiusLocation, this.radius);
  
  setupVertexAttribute(self.gl, self.program, "position", self.vertexBuffer, 2, 8, 0);
  drawElements(self.gl, self.indexBuffer, self.gl.TRIANGLES, 3*this.numSlices, 0);
});</code></pre>

    <p>This piece of code is nothing new. We did something very similar in Program 2. What is different in Program 3 is the way we compute the displacement and the shape that we draw.</p>

    <h2>12.4 &nbsp; Program 4: Using <code>struct</code> to animate multiple balls</h2>

    <p>In this section, we expand the program in the last section so that we can animate multiple balls at once. We want these balls to have different sizes, different colors, and move at different velocities. The source code of this section's program can be found in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-12/program-04"><code>chapter-12/program-04</code></a> directory of the book's code repository. The screenshot of the program can be seen below.</p>
    
    <figure class="figure">
      <table>
        <tr>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td align="center">(a)</td>
          <td align="center">(b)</td>
          <td align="center">(c)</td>
        </tr>
      </table
      <figcaption class="figure-caption"><strong>Figure 12.4</strong> Screenshots of Program 4, showing multiple balls of various sizes and colors moving through the screen at different directions. <b>TODO: Add screenshots.</b></figcaption>
    </figure>

    <h3>12.4.1 &nbsp; Modeling balls with a Javascript class</h3>

    <p>Surprisingly, animating multiple balls is not much more difficult from animating a single ball: we just have to do what we did in the last program multiple times. While Program 2 animates a white ball of radius $0.1$, the code is flexible enough to allow us to change the ball's radius and position. We just have to add some more code to allow colors other than white, and we would be able to achieve our goal.</p>

    <p>Because different balls have different properties such as radii, colors, and positions, we need to a good way to keep track of these properties inside our program. A standard way to do this under object-oriented programming (OOP) is to represent the concept of a ball a class, so that we can create multiple instances of it to represent different balls at run time. So, what should our ball class should store? The answer is all the data we have used before in the last program.</p>

    <ul>
      <li>The 2D displacement of the center of the ball.</li>
      <li>The velocity vector of the ball.</li>
    </ul>

    <p>We also need the following new pieces data.</p>

    <ul>
      <li>The radius of the ball.</li>
      <li>The RGB color of the ball.</li>
    </ul>

    <p>Because, in this section, we allow these properties to vary between instances. The Javascript class for balls is the <a href="https://github.com/pkhungurn/cg-book-code/blob/8372f7b82d025b30aae297129ab69198e725c3b3/chapter-12/program-04/src/index.js#L16"><code>Ball</code></a> class. Its fields are declared in its constructor, which is reproduced below.</p>

<pre><code class="language-c">class Ball {
  constructor(displacement, radius, velocity, color) {
    this.displacement = displacement;
    this.velocity = velocity;
    this.radius = radius;
    this.color = color;
  }

  :
  :
}</code></pre>

    <p>In the last section, we represent the displacement by two variables, <code>displacementX</code> and <code>displacementY</code>, and the same is true for the velocity. However, in this section, we will represent vectors by Javascript arrays in order to reduce the number of fields and make the code easier to read. Here, <code>displacement</code> is supposed to be an array of size 2, so that <code>displacement[0]</code> represents the $x$-component of the displacement, and <code>displacement[1]</code> represents the $y$-component. The same is also true for <code>velocity</code>. The field <code>radius</code> is obviously a single floating point number, but <code>color</code> should be an array of size 3 so that <code>color[0]</code>, <code>color[1]</code>, and <code>color[2]</code> represent the R, G, and B components of the color, respectively.</p>

    <p>After we have decided what fields the class should have, we need to decide what methods it should have. We know that Program 3 has to update the ball's displacement and velocity every frame in order to animate it. This piece of code is used repetitively, and it has to be executed for every ball we put on the screen. This makes it a good candidate to be refactored into a method so that we can refer to the whole process by a name. Let us call this method <code>update</code>.</p>

<pre><code class="language-c">update(delta) {
  this.displacement[0] += this.velocity[0] * delta;
  this.displacement[1] += this.velocity[1] * delta;
  
  if (this.displacement[0] > 1.0 - this.radius) {
    this.displacement[0] = 1.0 - this.radius;
    this.velocity[0] *= -1.0;
  }
  if (this.displacement[0] < -1.0 + this.radius) {
      this.displacement[0] = -1.0 + this.radius;
      this.velocity[0] *= -1.0;
  }
  if (this.displacement[1] > 1.0 - this.radius) {
    this.displacement[1] = 1.0 - this.radius;
    this.velocity[1] *= -1.0;
  }
  if (this.displacement[1] < -1.0 + this.radius) {
      this.displacement[1] = -1.0 + this.radius;
      this.velocity[1] *= -1.0
  }
}</code></pre>

    <p>We see that the method looks similar to the piece of code in Program 3 that updates the ball's displacement and velocity. The main difference with the old code is that many fields are now arrays instead of floating points, so the components of the vectors are now accessed differently. The variable <code>delta</code> is now an argument of the method instead of being a function variable like in the last program.</p>

    <p>Now that we have a comlete description of the <code>Ball</code> class, let us see how it is used in the program. The first thing we have to do is to create all the balls we want to animate, and this is done inside the constructor of the <code>WebGLApp</code> class.</p>

<pre><code class="language-c">
class WebGLApp {
  constructor() {
    :
    :

    this.balls = [];
    for (let i = 0; i < 16; i++) {
        let radius = 0.01 + (0.09) * Math.random();
    
        let displacement = [
            -1.0 + radius + (2.0 - 2 * radius) * Math.random(), 
            -1.0 + radius + (2.0 - 2 * radius) * Math.random()
        ];
        
        let angle = 2 * Math.PI * Math.random();
        let velocity = [
            Math.cos(angle) * 0.001,
            Math.sin(angle) * 0.001
        ];
    
        let color = [
            0.5 + 0.5 * Math.random(),
            0.5 + 0.5 * Math.random(),
            0.5 + 0.5 * Math.random()
        ];
    
        let ball = new Ball(displacement, radius, velocity, color);
    
        this.balls.push(ball);
    }

    :
    :
  }
}
</code></pre>

    <p>The above piece of code basically creates an array <code>balls</code> to store the instances of the <code>Ball</code> class. We then create 16 balls, randomizing their radii, initial displacement, initial velocity, and color. Because the background is black, we choose the RGB components to be in the range $[0.5, 1.0]$ to make all the balls easy to see.</p>

    <p>Inside the <code>updateWebGL</code> method, we need to call the <code>update</code> method to move each ball. This is quite easy now that we have refactored the updating code.</p>

<pre><code class="language-c">updateWebGL() {
  :
  :

  for (let i=0; i < this.balls.length; i++) {
    this.balls[i].update(delta);
  }

  :
  :
}</code></pre>

    <h3>12.4.2 &nbsp; <code>struct</code> uniform variables</h3>
  
    <p>Since we went through the trouble of grouping all variables related to a ball into a class in Javascript, we should do the same in GLSL because the code is easier to undestand if it mirrors the Javascript host code. As we said earlier in <a href="../chapter-10/index.html">Chapter 10</a>, the GLSL language does not have classes. The closest construct to a class is a <code>struct</code>, which can be thought of as class that have only fields but no methods. In both the vertex shader (<a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-12/program-03/src/vertex-shader.vert"><code>vertex-shader.vert</code></a>) and the fragment shader (<a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-12/program-03/src/fragment-shader.frag"><code>fragment-shader.frag</code></a>), we define a <code>struct</code> called <code>Ball</code> as follows:</p>

<pre><code class="language-c">struct Ball {
  vec2 displacement;
  float radius;
  vec3 color;
};</code></pre>

    <p>Note that, unlike the <code>Ball</code> class in Javasript, the <code>struct</code> does not have the <code>velocity</code> fields because, as we shall see, it is not used in GLSL. We also define a uniform variable <code>ball</code> of type <code>Ball</code> inside both the vertex and fragment shaders.</p>

<pre><code class="language-c">uniform Ball ball;</code></pre>

    <p>Let us see how this uniform variable is used insider the shaders. The easier usage is in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-12/program-04/src/fragment-shader.frag">fragment shader</a>, where we just set the output color to the color of the ball.</p>

<pre><code class="language-c">out vec4 fragColor;

void main() {
    fragColor = vec4(ball.color, 1.0);
}</code></pre>

    <p>The vertex shader is pretty much like the vertex shader of Program 3. The only change is that, instead of using the <code>radius</code> and <code>displacement</code> uniforms, we use the fields of the <code>ball</code> uniform instead.</p>

<pre><code class="language-c">in vec2 position;

void main() {
    gl_Position = vec4(position * ball.radius + ball.displacement, 0, 1);
}</code></pre>

    <p>Inside the Javascript program, we need to prepare a circle mesh just like what we did in Program 3. Then, we need to draw the circle multiple times, using the properties of each <code>Ball</code> instance. The relevant piece of code inside the <code>updateWebGL</code> method is as follows.</p>

<pre><code class="language-c">useProgram(this.gl, this.program, () => {
  for (let i=0; i &lt; this.balls.length; i++) {
    let ball = this.balls[i];

    let ballDisplacementLocation = self.gl.getUniformLocation(
      self.program, "ball.displacement");
    self.gl.uniform2fv(ballDisplacementLocation, ball.displacement);

    let ballRadiusLocation = self.gl.getUniformLocation(
      self.program, "ball.radius");
    self.gl.uniform1f(ballRadiusLocation, ball.radius);

    let ballColorLocation = self.gl.getUniformLocation(
      self.program, "ball.color");
    self.gl.uniform3fv(ballColorLocation, ball.color);
    
    setupVertexAttribute(
      self.gl, self.program, "position", self.vertexBuffer, 2, 8, 0);
    drawElements(
      self.gl, self.indexBuffer, self.gl.TRIANGLES, 3*this.numSlices, 0);
  }
}</code></pre>

    <p>We see that the main difference between the piece of code above and the equivalent portion from Program 3 is the <code>for</code> loop that iterates through the <code>balls</code> array. In each iteration of this loop, we set the relevant uniform variables and finally call <code>drawElements</code> to draw the circle that represents each ball. The uniform variables are now called "<code>ball.displacement</code>", "<code>ball.radius</code>", and "<code>ball.color</code>" instead of just "<code>displacement</code>" and "<code>radius</code>" like in the last program. This is simply because we now move these uniforms into a <code>struct</code>, and so we have to prefix their names with the struct's name and a dot (<code>.</code>).</p>

    <p>Notice also that we use two new WebGL commands: <code>uniform2fv</code> and <code>uniform3fv</code>. When <code>v</code> is the last letter of a <code>uniformXXX</code> method, the method accepts an array instead of the individual components of the vectors, allowing us to write more concise code. If we were to use <code>uniform3f</code> to assign <code>ball.color</code>, the code would have been</p>
    
<pre><code class="language-c">self.gl.uniform2fv(
  ballColortLocation, ball.color[0], ball.color[1], ball.color[2]);</code></pre>

    <p>which is quite lengthy indeed.</p>

    <h2>12.5 &nbsp; Summary</h2>

    <ul>
      <li>A <code>uniform variable</code> is a mechanism to pass information from the host program to a GLSL program.
      <ul>
        <li>It is a global variable in a GLSL program that can be set by the host Javascript program but not the GLSL program itself.</li>
        <li>Its value is the same when seen from the vertex shader and the fragment shader.</li>
      </ul>
      </li>      

      <li>One declares a uniform variable by adding the <code>uniform</code> keyword in front of a global variable declaration in the shaders.</li>

      <li>Assigning a value to a uniform variable is a two-step process.
      <ul>
        <li>Retrieve the location of the uniform variable using the <code>getUniformLocation</code> method.</li>
        <li>Set the value by using the <code>uniformXXX</code> methods.
          <ul>
            <li>Typically, <code>XXX</code> contains the number of components of the uniform variable and the data type of each component. For example, <code>unifrom3f</code> assigns to uniform variable that has 3 components, each of which is a floating-point number, which is a <code>vec3</code>.</li>

            <li>If there is a <code>v</code> at the end of the method name, the method accepts an array storing the values of the components instead of the individual components.</li>
          </ul>
        </li>
      </ul>
      </li>

      <li>One use case of uniform variables is to make the GLSL program responds to user inputs. This is what we did in Program 1. Another use case is to create animations, which is what we do in Program 2, 3, and 4.</li>

      <li>Creating an animation, we must keep track of time.
      <ul>
        <li>We can use <code>performance.now</code> to retrieve the current time in milliseconds.</li>
        <li>In our Javascript code, we need to keep track of the time since we started the program. Optinally, we can also keep track of the time since the last time we updated our OpenGL canvas.</li>
      </ul>
      </li>

      <li>In Program 2, 3, and 4, we define static meshes whose vertex and index buffers do not changes at all. However, we can move these meshes around by adding the same "displacement" to each vertex's positions. When the displacement changes over time, we can move the mesh around the screen.</li>

      <li>In Program 3, we create a mesh that represents a circle of radius 1 whose center is at the point $(0,0)$. However, we can render circles of arbitrary radii by multipying the vertex positions with the radius $r$.</li>

      <li>Uniform variables can be grouped into a <code>struct</code> in order to achieve better code organization.</li>

      <li>To retrieve the location of a field of a <code>struct</code> uniform variable, we must prefix the field's name with the name of the <code>struct</code> and the dot (<code>.</code>) symbol.</li>
    </ul>



    <hr>
    <p>
      <a href="../chapter-11/index.html"><<</a>
      <a href="../index.html">Contents</a>
    </p>
  </div>
  <script src="../js/bootstrap.bundle.min.js"></script>
  <script src="../js/littlefoot.js" type="application/javascript"></script>
  <script type="application/javascript">
    const { littlefoot } = require('littlefoot')

    const lf = littlefoot({
      activateOnHover: true,
      hoverDelay: 250,
    });
  </script>
</body>

</html>