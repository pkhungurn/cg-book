<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/theme.css" rel="stylesheet">
  <!-- MathJax -->
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        tags: "ams",
      },
      svg: {
        fontCache: 'global'
      },
    };
  </script>
  <script type="text/javascript" id="MathJax-script" src="../mathjax/tex-mml-chtml.js"></script>
  <link rel="stylesheet"
      href="../highlight/styles/default.min.css">
  <script src="../highlight/highlight.min.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script>
  hljs.highlightAll();
  hljs.initLineNumbersOnLoad();
  </script>
    
  <title>Chapter 13</title>
</head>

<body>
  <div class="container" style="max-width: 640px;">
    <span style="visibility: hidden;">
      \(
      \def\sc#1{\dosc#1\csod}
      \def\dosc#1#2\csod{{\rm #1{\small #2}}}

      \newcommand{\dee}{\mathrm{d}}
      \newcommand{\Dee}{\mathrm{D}}
      \newcommand{\In}{\mathrm{in}}
      \newcommand{\Out}{\mathrm{out}}
      \newcommand{\pdf}{\mathrm{pdf}}
      \newcommand{\Cov}{\mathrm{Cov}}
      \newcommand{\Var}{\mathrm{Var}}

      \newcommand{\ve}[1]{\mathbf{#1}}
      \newcommand{\mrm}[1]{\mathrm{#1}}
      \newcommand{\ves}[1]{\boldsymbol{#1}}
      \newcommand{\etal}{{et~al.}}
      \newcommand{\sphere}{\mathbb{S}^2}
      \newcommand{\modeint}{\mathcal{M}}
      \newcommand{\azimint}{\mathcal{N}}
      \newcommand{\ra}{\rightarrow}
      \newcommand{\mcal}[1]{\mathcal{#1}}
      \newcommand{\X}{\mathcal{X}}
      \newcommand{\Y}{\mathcal{Y}}
      \newcommand{\Z}{\mathcal{Z}}
      \newcommand{\x}{\mathbf{x}}
      \newcommand{\y}{\mathbf{y}}
      \newcommand{\z}{\mathbf{z}}
      \newcommand{\tr}{\mathrm{tr}}
      \newcommand{\sgn}{\mathrm{sgn}}
      \newcommand{\diag}{\mathrm{diag}}
      \newcommand{\Real}{\mathbb{R}}
      \newcommand{\sseq}{\subseteq}
      \newcommand{\ov}[1]{\overline{#1}}
      \DeclareMathOperator*{\argmax}{arg\,max}
      \DeclareMathOperator*{\argmin}{arg\,min}
      \)
    </span>

    <h1>13 &nbsp; Fragment Shaders</h1>
    <hr>

    <p>We learned that a WebGL program is made up of at least 3 programs: the host Javascript program, the vertex shaders, and the fragment shaders. In the past two chapters, we focused on the vertex shader and saw that it can be used to create complicated shapes in <a href="../chapter-11/index.html">Chapter 11</a>. We also learned that uniform variables can be used in the vertex shaders to create simple animations in <a href="../chapter-12/index.html">the last chapter</a>.</p>

    <p>In this chapter, we turn our attention to the fragment shader. Recall from <a href="../chapter-07/index.html#fragment-shaders">Chapter 7</a> that the fragment shader has two responsibilities: (1) deciding whether to discard a fragment or not, and (2) computing the color of the fragment if it is not discarded. We will see in this chapter that the fragment shader is very powerful because it determines colors that would finally appear on the screen.</p>

    <p>As you might recall from <a href="../chapter-02/">Chapter 2</a>, color is quite a complicated subject in its own right. A programmer must be aware of the color space of each color value they manipulate, and this is especially important when writing a fragment shader. Luckily, there are only two color spaces we need to worry about: linear and sRGB. In Program 1, we will discuss a function that converts from the linear space to the sRGB space and discuss why it is important. This function will be used throughout the rest of the book.</p>

    <p>The mechanism that makes the fragment shader powerful is the <b>varying variable</b>, which is a mechanism that allows the vertex shader to pass information to the fragment shader. Varying variables allow use to create color gradients, which we will demonstrate in Program 2.</p>

    <p>Moreover, varying variables allows the fragment shader to know about the fragment it is processing. One of the most useful information about the fragment is its position on the screen, and a way to set up the scene so that each fragmeht knows its position is to render a "full screen quad", which we will discuss in Program 3. The fragment position allows us to compute a color as a function of it, which is an image, and we shall see in Program 4 that this image can be very complicated even when our fragment shader is quite simple.</p>

    <h2>13.1 &nbsp; Program 1: Color spaces</h2>

    <h3>13.1.1 &nbsp; Color spaces and the fragment shader</h3>

    <p>Recall from <a href="../chapter-02/.index.html#color-spaces">Section 2.3</a> that a color space specifies the mapping from the RGB color cube the actual color that appearas on the screen. The color space used by your web browser is the <b>sRGB color space</b>. So, in an HTML file, when you specify the color <code>#EA8032</code>, which translates to the RGB value of $(234, 128, 50)$ or approximately $(0.92, 0.50, 0.20)$ if we use floating point numbers, the fact that you see the orange color <font color="#ea8032">â– </font> is because the sRGB color spaces chooses to associate $(0.92, 0.50, 0.20)$ with this particular color. We also learn that the sRGB color space is not physical, meaning that a tristimulus value of $0.5$ is not half as powerful (i.e., as bright) as $1.0$. The color space where tristimulus values corresponds to light power emitted by the monitor is the <b>linear color space</b>. We also learns the rule of thumb that all intermediate calculations should be performed in the the linear space while all output values should be in the sRGB space.</p>

    <p>How are the above facts and rule apply to how we should write fragment shaders? The first thing to keep in mind is that <b>any color value that appears on the screen is automatically in the sRGB color space.</b> This is simply because it is the color space that the browser uses. For all the previous programs up to this point, this output color is what we assign to the fragment shader's output variable, which is always called <code>fragColor</code>. So, this means that <code>fragColor</code> is always in the sRGB color space. (This will no longer apply when the fragment shader does not output to the screen, but we will talk about this later.)</p>

    <p>Second, to follow the "compute in linear, output in sRGB" rule, we should follow another two simple rules when we write our programs.</p>

    <ol>
      <li>All color variables other than <code>fragColor</code> are in the linear space.</li>
      <li>We must convert from linear to sRGB when assigning a value to <code>fragColor</code>.</li>
    </ol>

    <p>Unfortunately, there are no automatic mechanisms such as a compiler that would enforce these rules for us. The program must instead enforce these rules by themself. Being mindful of colors spaces practically means convering colors from one space to another at the right places in your program.</p>

    <h3>13.1.2 &nbsp; Difference between the color spaces</h3>

    <p>The main point of Program 1 is to show the reader the visual difference between being mindful and not being mindful of color spaces. When you run the program, you will see what is depicted in the screenshot below.</p>

    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-01-screenshot-00.png"><img src="images/program-01-screenshot-00.png" alt="" width="300"></a></td>          
        </tr>        
      </table>
      <figcaption class="figure-caption"><strong>Figure 13.1</strong> The initial state of Program 1.</figcaption>
    </figure>

    <p>The program acts like a color picker you would see in a painting program like Microsoft Paint, GIMP, or Photoshop. There are three sliders, each corresponding to a tristimulous value in the RGB color space. There are two canvases, one labelled "WebGL" and the other "HTML," that we would show the colors specified by the sliders. The WebGL canvas displays the color through the use of a WebGL program, and the HTML canvas displays the color by manipulating the <code>background-color</code> CSS property of the canvas itself. So, the color shown on the HTML canvas reflects how the web browser normally interprets color values. Lastly, the user how the WebGL canvas would process the color specified by the sliders. When the user chooses the "No conversion" radio box, the WebGL canvas would output the color specified by the sliders without performing any calculation on it. However, when the user chooses the "Linear to sRGB" radio box, the WebGL program would treat the color specified by the sliders to be in the linear color space and perform conversion from linear to sRGB before outputting the color to the canvas. Note that the "Linear to sRGB" option is the one consistent with the rules we discussed in the last section, while the "No conversion" option is not.</p>

    <p>To see what the options mean visually, let us manipulate the G slider so that the G value is $128 / 256 \approx 0.5$.</p>

    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-01-screenshot-01.png"><img src="images/program-01-screenshot-01.png" alt="" width="300"></a></td>          
        </tr>        
      </table>
      <figcaption class="figure-caption"><strong>Figure 13.2</strong> Program 1's displaying the color $(0, 0.5, 0)$ with the "No conversion" option.</figcaption>
    </figure>

    <p>We can see that the both canvases show the exact same color. This makes sense because, as we said earlier, the web browser's color space is sRGB. So, if the WebGL program just outputs the color without any modification, it would show the exact same color that the browser would natively show. However, if we switch to the "Linear to sRGB" option, we will see that the color in the WebGL canvas becomes brighter.</p>

    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-01-screenshot-02.png"><img src="images/program-01-screenshot-02.png" alt="" width="300"></a></td>          
        </tr>        
      </table>
      <figcaption class="figure-caption"><strong>Figure 13.3</strong> Program 1's displaying the color $(0, 0.5, 0)$ with the "Linera to sRGB" option.</figcaption>
    </figure>

    <p>This behavior is consistent with what we learned in <a href="../chapter-02/.index.html#color-spaces">Section 2.3</a>: the same color values would appear brighter if it is in the linear color space than when it is in the sRGB color space.</p>

    <h2>13.2 &nbsp; Program 2: Using varying variables to create color gradients</h2>

    <h2>13.2 &nbsp; Program 3: The full-screen quad</h2>

    <h2>13.3 &nbsp; Program 3: Displaying 2D functions</h2>

    <hr>
    <p>
      <a href="../chapter-12/index.html"><<</a>
      <a href="../index.html">Contents</a>
    </p>
  </div>
  <script src="../js/bootstrap.bundle.min.js"></script>
  <script src="../js/littlefoot.js" type="application/javascript"></script>
  <script type="application/javascript">
    const { littlefoot } = require('littlefoot')

    const lf = littlefoot({
      activateOnHover: true,
      hoverDelay: 250,
    });
  </script>
</body>

</html>