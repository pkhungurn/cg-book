<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/theme.css" rel="stylesheet">
  <!-- MathJax -->
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        tags: "ams",
      },
      svg: {
        fontCache: 'global'
      },
    };
  </script>
  <script type="text/javascript" id="MathJax-script" src="../mathjax/tex-mml-chtml.js"></script>
  <link rel="stylesheet"
      href="../highlight/styles/default.min.css">
  <script src="../highlight/highlight.min.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script>
  hljs.highlightAll();
  hljs.initLineNumbersOnLoad();
  </script>
    
  <title>Chapter 14</title>
</head>

<body>
  <div class="container" style="max-width: 640px;">
    <span style="visibility: hidden;">
      \(
      \def\sc#1{\dosc#1\csod}
      \def\dosc#1#2\csod{{\rm #1{\small #2}}}

      \newcommand{\dee}{\mathrm{d}}
      \newcommand{\Dee}{\mathrm{D}}
      \newcommand{\In}{\mathrm{in}}
      \newcommand{\Out}{\mathrm{out}}
      \newcommand{\pdf}{\mathrm{pdf}}
      \newcommand{\Cov}{\mathrm{Cov}}
      \newcommand{\Var}{\mathrm{Var}}

      \newcommand{\ve}[1]{\mathbf{#1}}
      \newcommand{\mrm}[1]{\mathrm{#1}}
      \newcommand{\ves}[1]{\boldsymbol{#1}}
      \newcommand{\etal}{{et~al.}}
      \newcommand{\sphere}{\mathbb{S}^2}
      \newcommand{\modeint}{\mathcal{M}}
      \newcommand{\azimint}{\mathcal{N}}
      \newcommand{\ra}{\rightarrow}
      \newcommand{\mcal}[1]{\mathcal{#1}}
      \newcommand{\X}{\mathcal{X}}
      \newcommand{\Y}{\mathcal{Y}}
      \newcommand{\Z}{\mathcal{Z}}
      \newcommand{\x}{\mathbf{x}}
      \newcommand{\y}{\mathbf{y}}
      \newcommand{\z}{\mathbf{z}}
      \newcommand{\tr}{\mathrm{tr}}
      \newcommand{\sgn}{\mathrm{sgn}}
      \newcommand{\diag}{\mathrm{diag}}
      \newcommand{\Real}{\mathbb{R}}
      \newcommand{\sseq}{\subseteq}
      \newcommand{\ov}[1]{\overline{#1}}
      \DeclareMathOperator*{\argmax}{arg\,max}
      \DeclareMathOperator*{\argmin}{arg\,min}
      \)
    </span>

    <h1>14 &nbsp; Abstracting OpenGL</h1>
    <hr>

    <p>We learned in the past few chapters of the essential components of a GLSL program: vertex shader, fragment shader, vertex attributes, uniform variables, and varying variables. We also learned that rendering a mesh involves multiple steps. We need to create buffers to store vertex data. Then, we need to create a buffer to store the vertex indices that make up primitives. We then use a GLSL program and setup all of its vertex attributes and uniform variables. Finally, we must bind the index buffer and issue a drawing command.</p>

    <p>Because of all the above details, we can see that it can be hard to manage those objects, especially in more complex WebGL applications where we might have multiple GLSL programs and multiple meshes. One bad aspect of the way we have written the code so far is that <i>things are not properly encapsulated</i>. This means that things that should be parts of a larger object are not bundled together. For example, when we create a mesh, we need to create two variables: one for the vertex buffer and another for the index buffer. There is nothing to indicate that these two buffers should always be used together, and so the programmer has to keep track of this fact themself.</p>

    <p>Another worrying aspect is that the programmer must also keep track of the vertex attributes and uniform variables of all GLSL programs. Because the programmer can name these variables in any way they want, there can be too many names to remember, and this can lead to bugs that are hard to identify. Fortunately, it turns out that GLSL programs in generally tend to use only a small set of vertex attributes. So, we can reduce the cognitive load on the programmer by naming attributes with the same semantics with the same names.</p>
      
    <p>Still, because different GLSL programs serve different purposes, some programs might use one particular vertex attribute (for examples, the vertex color) while others do not. As a result, we need the ability to identify which vertex attributes are present in a GLSL program.</p>

    <p>This chapter presents a way to solve the above programs by creating new abstractions (i.e., classes) for GLSL programs and colored meshes. These abstractions are what the author personally use in his personal projects, and they will be use in later chapters of the book. We choose to introduce them here because he thinks he would not be able to manage WebGL's complexity without them. A decent programmer must know the limit of their cognitive capacity and introduce appropriate abstractions to make their life easier.</p>

    <h2>14.1 &nbsp; An abstraction for GLSL programs</h2>

    <p>WebGL already has an abstraction for GLSL programs: the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> class. However, the author finds that they are not the most convenient to use. In particular, <code>WebGLProgram</code> does not have any information about the vertex attributes or the uniforms of the GLSL program it represents. Moreover, working with vertex attributes and uniforms require issuing at least two WebGL commands. First, we must issue one to get the variable's location. Only then we can issue another command to do what we want with the variable itself.</p>

    <h2>14.2 &nbsp; An abstraction for colored meshes</h2>

    <hr>
    <p>
      <a href="../chapter-13/index.html">&lt;&lt;</a>
      <a href="../index.html">Contents</a>      
    </p>
  </div>
  <script src="../js/bootstrap.bundle.min.js"></script>
  <script src="../js/littlefoot.js" type="application/javascript"></script>
  <script type="application/javascript">
    const { littlefoot } = require('littlefoot')
ou
    const lf = littlefoot({
      activateOnHover: true,
      hoverDelay: 250,
    });
  </script>
</body>

</html>