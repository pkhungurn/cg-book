<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/theme.css" rel="stylesheet">
  <!-- MathJax -->
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        tags: "ams",
      },
      svg: {
        fontCache: 'global'
      },
    };
  </script>
  <script type="text/javascript" id="MathJax-script" src="../mathjax/tex-mml-chtml.js"></script>
  <link rel="stylesheet"
      href="../highlight/styles/default.min.css">
  <script src="../highlight/highlight.min.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script>
  hljs.highlightAll();
  hljs.initLineNumbersOnLoad();
  </script>
    
  <title>Chapter 14</title>
</head>

<body>
  <div class="container" style="max-width: 640px;">
    <span style="visibility: hidden;">
      \(
      \def\sc#1{\dosc#1\csod}
      \def\dosc#1#2\csod{{\rm #1{\small #2}}}

      \newcommand{\dee}{\mathrm{d}}
      \newcommand{\Dee}{\mathrm{D}}
      \newcommand{\In}{\mathrm{in}}
      \newcommand{\Out}{\mathrm{out}}
      \newcommand{\pdf}{\mathrm{pdf}}
      \newcommand{\Cov}{\mathrm{Cov}}
      \newcommand{\Var}{\mathrm{Var}}

      \newcommand{\ve}[1]{\mathbf{#1}}
      \newcommand{\mrm}[1]{\mathrm{#1}}
      \newcommand{\ves}[1]{\boldsymbol{#1}}
      \newcommand{\etal}{{et~al.}}
      \newcommand{\sphere}{\mathbb{S}^2}
      \newcommand{\modeint}{\mathcal{M}}
      \newcommand{\azimint}{\mathcal{N}}
      \newcommand{\ra}{\rightarrow}
      \newcommand{\mcal}[1]{\mathcal{#1}}
      \newcommand{\X}{\mathcal{X}}
      \newcommand{\Y}{\mathcal{Y}}
      \newcommand{\Z}{\mathcal{Z}}
      \newcommand{\x}{\mathbf{x}}
      \newcommand{\y}{\mathbf{y}}
      \newcommand{\z}{\mathbf{z}}
      \newcommand{\tr}{\mathrm{tr}}
      \newcommand{\sgn}{\mathrm{sgn}}
      \newcommand{\diag}{\mathrm{diag}}
      \newcommand{\Real}{\mathbb{R}}
      \newcommand{\sseq}{\subseteq}
      \newcommand{\ov}[1]{\overline{#1}}
      \DeclareMathOperator*{\argmax}{arg\,max}
      \DeclareMathOperator*{\argmin}{arg\,min}
      \)
    </span>

    <h1>14 &nbsp; Abstracting OpenGL</h1>
    <hr>

    <p>We learned in the past few chapters of the essential components of a GLSL program: vertex shader, fragment shader, vertex attributes, uniform variables, and varying variables. We also learned that rendering a mesh involves multiple steps. We need to create buffers to store vertex data. Then, we need to create a buffer to store the vertex indices that make up primitives. We then use a GLSL program and setup all of its vertex attributes and uniform variables. Finally, we must bind the index buffer and issue a drawing command.</p>

    <p>Because of all the above details, we can see that it can be hard to manage those objects, especially in more complex WebGL applications where we might have multiple GLSL programs and multiple meshes. One bad aspect of the way we have written the code so far is that <i>things are not properly encapsulated</i>. This means that things that should be parts of a larger object are not bundled together. For example, when we create a mesh, we need to create two variables: one for the vertex buffer and another for the index buffer. There is nothing to indicate that these two buffers should always be used together, and so the programmer has to keep track of this fact themself.</p>

    <p>Another worrying aspect is that the programmer must also keep track of the vertex attributes and uniform variables of all GLSL programs. Because the programmer can name these variables in any way they want, there can be too many names to remember, and this can lead to bugs that are hard to identify. Fortunately, it turns out that GLSL programs in generally tend to use only a small set of vertex attributes. So, we can reduce the cognitive load on the programmer by naming attributes with the same semantics with the same names.</p>
      
    <p>Still, because different GLSL programs serve different purposes, some programs might use one particular vertex attribute (for examples, the vertex color) while others do not. As a result, we need the ability to identify which vertex attributes are present in a GLSL program.</p>

    <p>This chapter presents a way to solve the above programs by creating new abstractions (i.e., classes) for GLSL programs and colored meshes. These abstractions are what the author personally use in his personal projects, and they will be use in later chapters of the book. We choose to introduce them here because he thinks he would not be able to manage WebGL's complexity without them. A decent programmer must know the limit of their cognitive capacity and introduce appropriate abstractions to make their life easier.</p>

    <h2>14.1 &nbsp; An abstraction for GLSL programs</h2>

    <p>WebGL already has an abstraction for GLSL programs: the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> class. However, the author finds that they are not the most convenient to use. In particular, <code>WebGLProgram</code> does not have any information about the vertex attributes or the uniforms of the GLSL program it represents. Moreover, working with vertex attributes and uniforms require issuing at least two WebGL commands. First, we must issue one to get the variable's location. Only then we can issue another command to do what we want with the variable itself.</p>

    <h3>14.1.1 &nbsp; <code>GlProgram</code></h3>

    <p>To deal with the above problem, we introduce a new class called <code>GlProgram</code> that encapsulates a GLSL program together with its vertex attributes and uniforms. The source code for the class is available in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01/src/program.js"><code>program.js</code></a> file in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-14/program-01/src"><code>chapter-14/program-01/src</code></a> directory. Before going into the details of how the class is implemented, let us see what it accomplishes. Using the code we have developed so far in the book, a typical sequence of commands when we use a GLSL program to render some primitives is as follows.</p>

<pre><code class="language-c">// Step 1: Create the program.
this.program = createGlslProgram(
  this.gl, vertexShaderSource, fragmentShaderSource);

// Step 2: Use programs.
let self = this;
useProgram(this.gl, this.program, () => {
  // Step 3: Set the values of uniforms.
  let centerLocation = self.gl.getUniformLocation(self.program, "center");
  self.gl.uniform2f(centerLocation, centerX, centerY);

  let scaleLocation = self.gl.getUniformLocation(self.program, "scale");
  self.gl.uniform1f(scaleLocation, scale);

  // Step 4: Set up the vertex attributes.
  setupVertexAttribute(
    self.gl, self.program, "vert_position", self.vertexBuffer, 2, 4*5, 0);
  setupVertexAttribute(
    self.gl, self.program, "vert_color", self.vertexBuffer, 3, 4*5, 4*2);

  // Step 5: Call drawElements to draw the primitives.
  drawElements(self.gl, self.indexBuffer, self.gl.TRIANGLES, 6, 0);
});
</code></pre>

    <p>Using the <code>GlProgram</code> class, we can shorten the code above.</p>

<pre><code class="language-c">// Step 1: Create the program
this.program = new GlProgram(
  this.gl, vertexShaderSource, fragmentShaderSource);
  
// Step 2: Use the program.
let self = this;
this.program.use(() => {
  // Step 3: Set the values of uniforms.
  self.program.uniform("center")?.set2Float(centerX, centerY);
  self.program.uniform("scale")?.set1Float(scale);

  // Step 4: Set up the vertex attributes.
  self.program.attribute("vert_position")?.setup(
    self.vertexBuffer, 2, 4*5, 0);
  self.program.attribute("vert_color")?.setup(
    self.vertexBuffer, 3, 4*5, 4*2);

  // Step 5: Call drawElements to draw the primitives.
  drawElements(self.gl, self.indexBuffer, self.gl.TRIANGLES, 6, 0);
});
</code></pre>

    <p>There are cosmetic changes such as how the <code>program</code> field is initialized and the fact that the <code>useProgram</code> function has become a method. The substantive changes, though, are how the uniforms and vertex attributes are accessed. The <code>GlProgram</code> class has the <code>uniform</code> and <code>attribute</code> methods that take a name and returns an object representing a uniform or an attribute, respectively. However, the methods are written so that they return <code>null</code> if there are uniforms or attributes with the given name. This is why we use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> operator (<code>?.</code>) to invoke the methods (i.e., <code>set2Float</code>, <code>set1Float</code>, and <code>setup</code>) of these objects.</p>

    <p>The author argues that the benefits of the new abstraction is not only that the code becomes a little shorter, but also the fact that the vertex attributes and the uniforms are accessed somewhat like fields of the <code>program</code> object. It makes the code easier to read and aligned with the fact that attributes are uniforms are part of a GLSL program.</p>

    <p>Another benefits that is not obvious from reading the code is that it eases shader debugging. Debugging any code involves changing the code a little bit and running the changed code to try to discover the root cause of the bug or test a hypothesis. When we debug a GLSL shader, we often rewrite the code so that some vertex attributes or uniforms becomes unused so that the shader becomes simpler and easier to understand. The problem is that, when such an object becomes unused, the GLSL compiler will automatically removes it completely from the GLSL program, and that means that any attempts to access them would cause an error. For example, if we change the code so that it temporarily does not use the <code>center</code> uniform, then the <code>self.gl.getUniformLocation(self.program, "center")</code> command would return <code>null</code> instead of valid <code>WebGLUniformLocation</code> object. Then, the subsequent <code>self.gl.uniform2f(centerLocation, centerX, centerY);</code> would result in an error. It is annoying to have to modify the Javascript code every time we make such changes to the shader. On the other hand, the line</p>

<pre><code class="language-c">self.program.uniform("center")?.set2Float(centerX, centerY);</code></pre>

    <p>automatically skips the setting of the uniform if it does not exist, and this allows us to focus more on the GLSL code rather than modifying the Javascript host code to avoid errors.</p>

    <h3>14.1.3 &nbsp; Overall structure</h3>

    <p>Let's take a look at the overall structure of the <code>GlProgram</code> class, whose source code is available in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01/src/index.js"><code>program.js</code></a> file of <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01">Program 1</a> of <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14">Chapter 14</a>. The class has a constructor and the following three methods:
      <ul>
        <li><code>use</code>,</li>
        <li><code>attribute</code>, and</li>
        <li><code>uniform</code>.</li>
      </ul>
    Here, <code>attribute</code> and <code>uniform</code> are accessors for the vertex attributes and uniforms, which we just mentioned earlier. The <code>use</code> does what its name suggest and serves the same function as the <code>useProgram</code> function we have been utilizing up until this point.
    </p>

    <p>The class has four fields: <code>gl</code>, <code>glObject</code>, <code>attributes</code>, and <code>uniforms</code>. The <code>gl</code> field wholes the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext"><code>WebGLRenderingContext</code></a> through which all WebGL commands are issued.  The <code>glObject</code> field holds the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> object that the WebGL API provides when we create a GLSL program. The fields <code>attributes</code> and <code>uniforms</code> are Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a> that sends a name to an object representing an attribute or a uniform with that time. The constructor initialize the fields as follows.</p>

<pre><code class="language-c">export class GlProgram{
    constructor(gl, vertexShaderSource, fragmentShaderSource) {
        this.gl = gl;
        this.glObject = createGlslProgram(
          gl, vertexShaderSource, fragmentShaderSource);

        this.attributes = new Map();
        // Code that fills this.attributes.
           :
           :
        
        this.uniforms = new Map();        
        // Code that fills this.uniforms.
           :
           :
    }
}</code></pre>

    <p>Like what we have done before, we create an instance of <code>WebGLProgram</code> with the <a href="https://github.com/pkhungurn/cg-book-code/blob/c1e13b8f71d47ec0fac3fd6ed9313fa2cd71af27/chapter-14/program-01/src/program.js#L24"><code>createGlslProgram</code></a> function and save the return value in the <code>glObject</code> field. The <code>atttributes</code> and <code>uniforms</code> fields initially hold two new empty <code>Map</code>s. We shall discuss how the maps are filled in the next subsections.</p>

    <p>The <code>use</code> method is just a reimplementation of the <code>useProgram</code> function.</p>

<pre><code>use(code) {
  this.gl.useProgram(this.glObject);
  code();
  this.gl.useProgram(null);
}    
</code></pre>

    <p>With the explanation of the easy parts completed, let us discuss how we model vertex attributes and uniform variables.</p>

    <h3>14.1.4 &nbsp; Modeling vertex attributes</h3>

    <p>Our goal here is to create an object that represents each vertex attribute of a GLSL program so that we may have a nicer interface to work with. As a result, we need to extract information about vertex attributes from a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> object. The first bit of information we need is how many vertex attributes a program has. This can be objected using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getProgramParameter"><code>getProgramParameter</code></a> method of the WebGL context, passing the <code>WebGLProgram</code> instance and the contant <code>ACTIVE_ATTRIBUTES</code> as arguments. The method is used in the constructor of the <code>GlProgram</code> class as follows.</p>

<pre><code class="language-c">let numAttributes = gl.getProgramParameter(
  this.glObject, gl.ACTIVE_ATTRIBUTES);</code></pre>

    <p>WebGL refers to the vertex atrributes with integer indices from 0 to <code>numAttributes</code>-1, and it provides us a way to query information about a vertex attribute given its index. We shall use this mechanism inside the constructor of a <a href="https://github.com/pkhungurn/cg-book-code/blob/c1e13b8f71d47ec0fac3fd6ed9313fa2cd71af27/chapter-14/program-01/src/program.js#L59"><code>GlAttribute</code></a> object, which we create to model a vertex attribute. Before discussing the details of the class, let us see how the <code>GlAttribute</code> objects are instantiated.</p>

<pre><code class="language-c">this.attributes = new Map();
for (let index = 0; index &lt; numAttributes; index++) {
  let attribute = new GlAttribute(gl, this, index);
  this.attributes.set(attribute.name, attribute);
}</code></pre>

    <p>Here, we create field called <code>attributes</code> that is a Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a> which allows us to refer to vertex attributes by their names. We then loop through the indices of the vertex attributs and create an instance of <code>GlAttribute</code> for each of the index. The created will have a field called <code>name</code>, which we can use when we add the object to the map. Once the loop has finished running, we can use the <code>attributes</code> field to implement the <code>attribute</code> method of the <code>GlProgram</code> class that we discuss in the last section as follows.</p>

<pre><code class="language-c">attribute(name) {
  if (this.attributes.has(name)) {
    return this.attributes.get(name);
  } else {
    return null;
  }
}</code></pre>

    <p>Now, let us discuss the implementation of the <code>GlAttribute</code> object itself. The following is the its constructor.</p>

<pre><code class="language-c">export class GlAttribute {
  constructor(gl, program, index) {
    this.gl = gl;
    this.program = program;
    this.index = index;

    let info = gl.getActiveAttrib(program.glObject, index);
    this.name = info.name;
    this.size = info.size;
    this.type = info.type;
    this.location = gl.getAttribLocation(program.glObject, this.name);
    this.enabled = false;
  }

  :
  :
}</code></pre>

    <p>The constructor accepts three arguments: the WebGL context, the <code>GlProgram</code> object to which this <code>GlAttribute</code> object belongs, and lastly <code>the index</code> of the vertex attribute. The first three lines of the constructor saves the arguments as fields. The rest of the constructor extracts and saves information about the vertex attribute itself.</p>

    <p>First, we call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getActiveAttrib"><code>getAttiveAttrib</code></a> method of the WebGL context, passing the <code>WebGLProgram</code> instance stored in the <code>GlProgram</code> object and the index of the vertex attribute as arguments. The method would return the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLActiveInfo"><code>WebGLActiveInfo</code></a>, which has three fields.
    <ul>
      <li><code>name</code> is the name of the vertex attribute.</li>
      <li><code>size</code> is the "size" of the field. It is 1 if the field is not an array, and the number of elements in the array if the field is an array.</li>
      <li><code>type</code> is the data type of each of the component of the field. These are WebGL-specific constants such as <code>FLOAT</code>, <code>FLOAT_VEC2</code>, <code>FLOAT_VEC3</code>, <code>INT</code>, and <code>INT_VEC4</code>, and so on.</li>
    </ul>
    We then save these fields of the <code>WebGLActiveInfo</code> as fields of the <code>GlAttribute</code> instance.</p>

    <p>The next step is to retrieve the location of the vertex attribute. We have done this before in most programs in the previous chapters. However, this time, we do not specify the name of the vertex attribute ourselves but use the name we queried using the <code>glActiveInfo</code> method.</p>

    <p>Lastly, we initialize the <code>enabled</code> field to <code>false</code>. This field keeps track whether the vertex attribute has been enabled using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray"><code>enableVertexAttribArray</code></a> method or not.</p>

    <p>The class has two methods. The first is <code>setEnabled</code>, which we will not use directly most of the time.</p>

<pre><code class="language-c">setEnabled(enabled) {
    if (enabled) {
        this.gl.enableVertexAttribArray(this.location);
        this.enabled = true;
    } else {
        this.gl.glDisableVertexAttribArray(this.location);
        this.enabled = false;
    }
}</code></pre>

    <p>The argument <code>enabled</code> is a boolean that indicates whether the user wants to enable of disable the attribute. So, to enable, we call <code>enable(true)</code>, and, to disable, we call <code>enable(false)</code>. The other method is the <code>setup</code> method, which replaces the <code>setupVertexAttribute</code> function we have been using so far.</p>

<pre><code class="language-c">setup(buffer, size, stride, offset, type=null, normalized=false) {
  this.setEnabled(true);
  type = type || this.gl.FLOAT;
  let self = this;
  bindBuffer(this.gl, this.gl.ARRAY_BUFFER, buffer, () => {
    self.gl.vertexAttribPointer(
      self.location, size, type, normalized, stride, offset);
  });
}</code></pre>

    <p>With the <code>setup</code> method in place, we can succinctly setup vertex attributes as like we discussed in the last section.</p>

<pre><code class="language-c">self.program.attribute("vert_position")?.setup(
  self.vertexBuffer, 2, 4*5, 0);
self.program.attribute("vert_color")?.setup(
  self.vertexBuffer, 3, 4*5, 4*2);</code></pre>

    <h3>14.1.5 &nbsp; Modeling uniform variables</h3>

    <h3>14.1.6 &nbsp; Program 1</h3>

    <h2>14.2 &nbsp; An abstraction for colored meshes</h2>

    <hr>
    <p>
      <a href="../chapter-13/index.html">&lt;&lt;</a>
      <a href="../index.html">Contents</a>      
    </p>
  </div>
  <script src="../js/bootstrap.bundle.min.js"></script>
  <script src="../js/littlefoot.js" type="application/javascript"></script>
  <script type="application/javascript">
    const { littlefoot } = require('littlefoot')
ou
    const lf = littlefoot({
      activateOnHover: true,
      hoverDelay: 250,
    });
  </script>
</body>

</html>