<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/theme.css" rel="stylesheet">
  <!-- MathJax -->
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        tags: "ams",
      },
      svg: {
        fontCache: 'global'
      },
    };
  </script>
  <script type="text/javascript" id="MathJax-script" src="../mathjax/tex-mml-chtml.js"></script>
  <link rel="stylesheet"
      href="../highlight/styles/default.min.css">
  <script src="../highlight/highlight.min.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script>
  hljs.highlightAll();
  hljs.initLineNumbersOnLoad();
  </script>
    
  <title>Chapter 14</title>
</head>

<body>
  <div class="container" style="max-width: 640px;">
    <span style="visibility: hidden;">
      \(
      \def\sc#1{\dosc#1\csod}
      \def\dosc#1#2\csod{{\rm #1{\small #2}}}

      \newcommand{\dee}{\mathrm{d}}
      \newcommand{\Dee}{\mathrm{D}}
      \newcommand{\In}{\mathrm{in}}
      \newcommand{\Out}{\mathrm{out}}
      \newcommand{\pdf}{\mathrm{pdf}}
      \newcommand{\Cov}{\mathrm{Cov}}
      \newcommand{\Var}{\mathrm{Var}}

      \newcommand{\ve}[1]{\mathbf{#1}}
      \newcommand{\mrm}[1]{\mathrm{#1}}
      \newcommand{\ves}[1]{\boldsymbol{#1}}
      \newcommand{\etal}{{et~al.}}
      \newcommand{\sphere}{\mathbb{S}^2}
      \newcommand{\modeint}{\mathcal{M}}
      \newcommand{\azimint}{\mathcal{N}}
      \newcommand{\ra}{\rightarrow}
      \newcommand{\mcal}[1]{\mathcal{#1}}
      \newcommand{\X}{\mathcal{X}}
      \newcommand{\Y}{\mathcal{Y}}
      \newcommand{\Z}{\mathcal{Z}}
      \newcommand{\x}{\mathbf{x}}
      \newcommand{\y}{\mathbf{y}}
      \newcommand{\z}{\mathbf{z}}
      \newcommand{\tr}{\mathrm{tr}}
      \newcommand{\sgn}{\mathrm{sgn}}
      \newcommand{\diag}{\mathrm{diag}}
      \newcommand{\Real}{\mathbb{R}}
      \newcommand{\sseq}{\subseteq}
      \newcommand{\ov}[1]{\overline{#1}}
      \DeclareMathOperator*{\argmax}{arg\,max}
      \DeclareMathOperator*{\argmin}{arg\,min}
      \)
    </span>

    <h1>14 &nbsp; Abstracting OpenGL</h1>
    <hr>

    <p>We learned in the past few chapters of the essential components of a GLSL program: vertex shader, fragment shader, vertex attributes, uniform variables, and varying variables. We also learned that rendering a mesh involves multiple steps. We need to create buffers to store vertex data. Then, we need to create a buffer to store the vertex indices that make up primitives. We then use a GLSL program and setup all of its vertex attributes and uniform variables. Finally, we must bind the index buffer and issue a drawing command.</p>

    <p>Because of all the above details, we can see that it can be hard to manage those objects, especially in more complex WebGL applications where we might have multiple GLSL programs and multiple meshes. One bad aspect of the way we have written the code so far is that <i>things are not properly encapsulated</i>. This means that things that should be parts of a larger object are not bundled together. For example, when we create a mesh, we need to create two variables: one for the vertex buffer and another for the index buffer. There is nothing to indicate that these two buffers should always be used together, and so the programmer has to keep track of this fact themself.</p>

    <p>Another worrying aspect is that the programmer must also keep track of the vertex attributes and uniform variables of all GLSL programs. Because the programmer can name these variables in any way they want, there can be too many names to remember, and this can lead to bugs that are hard to identify. Fortunately, it turns out that GLSL programs in generally tend to use only a small set of vertex attributes. So, we can reduce the cognitive load on the programmer by naming attributes with the same semantics with the same names.</p>
      
    <p>Still, because different GLSL programs serve different purposes, some programs might use one particular vertex attribute (for examples, the vertex color) while others do not. As a result, we need the ability to identify which vertex attributes are present in a GLSL program.</p>

    <p>This chapter presents a way to solve the above programs by creating new abstractions (i.e., classes) for GLSL programs and colored meshes. These abstractions are what the author personally use in his personal projects, and they will be use in later chapters of the book. We choose to introduce them here because he thinks he would not be able to manage WebGL's complexity without them. A decent programmer must know the limit of their cognitive capacity and introduce appropriate abstractions to make their life easier.</p>

    <h2>14.1 &nbsp; An abstraction for GLSL programs</h2>

    <p>WebGL already has an abstraction for GLSL programs: the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> class. However, the author finds that they are not the most convenient to use. In particular, <code>WebGLProgram</code> does not have any information about the vertex attributes or the uniforms of the GLSL program it represents. Moreover, working with vertex attributes and uniforms require issuing at least two WebGL commands. First, we must issue one to get the variable's location. Only then we can issue another command to do what we want with the variable itself.</p>

    <h3>14.1.1 &nbsp; <code>GlProgram</code></h3>

    <p>To deal with the above problem, we introduce a new class called <code>GlProgram</code> that encapsulates a GLSL program together with its vertex attributes and uniforms. The source code for the class is available in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01/src/program.js"><code>program.js</code></a> file in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-14/program-01/src"><code>chapter-14/program-01/src</code></a> directory. Before going into the details of how the class is implemented, let us see what it accomplishes. Using the code we have developed so far in the book, a typical sequence of commands when we use a GLSL program to render some primitives is as follows.</p>

<pre><code class="language-c">// Step 1: Create the program.
this.program = createGlslProgram(
  this.gl, vertexShaderSource, fragmentShaderSource);

// Step 2: Use programs.
let self = this;
useProgram(this.gl, this.program, () => {
  // Step 3: Set the values of uniforms.
  let centerLocation = self.gl.getUniformLocation(self.program, "center");
  self.gl.uniform2f(centerLocation, centerX, centerY);

  let scaleLocation = self.gl.getUniformLocation(self.program, "scale");
  self.gl.uniform1f(scaleLocation, scale);

  // Step 4: Set up the vertex attributes.
  setupVertexAttribute(
    self.gl, self.program, "vert_position", self.vertexBuffer, 2, 4*5, 0);
  setupVertexAttribute(
    self.gl, self.program, "vert_color", self.vertexBuffer, 3, 4*5, 4*2);

  // Step 5: Call drawElements to draw the primitives.
  drawElements(self.gl, self.indexBuffer, self.gl.TRIANGLES, 6, 0);
});
</code></pre>

    <p>Using the <code>GlProgram</code> class, we can shorten the code above.</p>

<pre><code class="language-c">// Step 1: Create the program
this.program = new GlProgram(
  this.gl, vertexShaderSource, fragmentShaderSource);
  
// Step 2: Use the program.
let self = this;
this.program.use(() => {
  // Step 3: Set the values of uniforms.
  self.program.uniform("center")?.set2Float(centerX, centerY);
  self.program.uniform("scale")?.set1Float(scale);

  // Step 4: Set up the vertex attributes.
  self.program.attribute("vert_position")?.setup(
    self.vertexBuffer, 2, 4*5, 0);
  self.program.attribute("vert_color")?.setup(
    self.vertexBuffer, 3, 4*5, 4*2);

  // Step 5: Call drawElements to draw the primitives.
  drawElements(self.gl, self.indexBuffer, self.gl.TRIANGLES, 6, 0);
});
</code></pre>

    <p>There are cosmetic changes such as how the <code>program</code> field is initialized and the fact that the <code>useProgram</code> function has become a method. The substantive changes, though, are how the uniforms and vertex attributes are accessed. The <code>GlProgram</code> class has the <code>uniform</code> and <code>attribute</code> methods that take a name and returns an object representing a uniform or an attribute, respectively. However, the methods are written so that they return <code>null</code> if there are uniforms or attributes with the given name. This is why we use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a> operator (<code>?.</code>) to invoke the methods (i.e., <code>set2Float</code>, <code>set1Float</code>, and <code>setup</code>) of these objects.</p>

    <p>The author argues that the benefits of the new abstraction is not only that the code becomes a little shorter, but also the fact that the vertex attributes and the uniforms are accessed somewhat like fields of the <code>program</code> object. It makes the code easier to read and aligned with the fact that attributes are uniforms are part of a GLSL program.</p>

    <p>Another benefits that is not obvious from reading the code is that it eases shader debugging. Debugging any code involves changing the code a little bit and running the changed code to try to discover the root cause of the bug or test a hypothesis. When we debug a GLSL shader, we often rewrite the code so that some vertex attributes or uniforms becomes unused so that the shader becomes simpler and easier to understand. The problem is that, when such an object becomes unused, the GLSL compiler will automatically removes it completely from the GLSL program, and that means that any attempts to access them would cause an error. For example, if we change the code so that it temporarily does not use the <code>center</code> uniform, then the <code>self.gl.getUniformLocation(self.program, "center")</code> command would return <code>null</code> instead of valid <code>WebGLUniformLocation</code> object. Then, the subsequent <code>self.gl.uniform2f(centerLocation, centerX, centerY);</code> would result in an error. It is annoying to have to modify the Javascript code every time we make such changes to the shader. On the other hand, the line</p>

<pre><code class="language-c">self.program.uniform("center")?.set2Float(centerX, centerY);</code></pre>

    <p>automatically skips the setting of the uniform if it does not exist, and this allows us to focus more on the GLSL code rather than modifying the Javascript host code to avoid errors.</p>

    <h3>14.1.3 &nbsp; Overall structure</h3>

    <p>Let's take a look at the overall structure of the <code>GlProgram</code> class, whose source code is available in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01/src/index.js"><code>program.js</code></a> file of <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01">Program 1</a> of <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14">Chapter 14</a>. The class has a constructor and the following three methods:
      <ul>
        <li><code>use</code>,</li>
        <li><code>attribute</code>, and</li>
        <li><code>uniform</code>.</li>
      </ul>
    Here, <code>attribute</code> and <code>uniform</code> are accessors for the vertex attributes and uniforms, which we just mentioned earlier. The <code>use</code> does what its name suggest and serves the same function as the <code>useProgram</code> function we have been utilizing up until this point.
    </p>

    <p>The class has four fields: <code>gl</code>, <code>glObject</code>, <code>attributes</code>, and <code>uniforms</code>. The <code>gl</code> field wholes the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext"><code>WebGLRenderingContext</code></a> through which all WebGL commands are issued.  The <code>glObject</code> field holds the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> object that the WebGL API provides when we create a GLSL program. The fields <code>attributes</code> and <code>uniforms</code> are Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a> that sends a name to an object representing an attribute or a uniform with that time. The constructor initialize the fields as follows.</p>

<pre><code class="language-c">export class GlProgram{
    constructor(gl, vertexShaderSource, fragmentShaderSource) {
        this.gl = gl;
        this.glObject = createGlslProgram(
          gl, vertexShaderSource, fragmentShaderSource);

        // Code that fills this.attributes.
        this.attributes = new Map();
           :
           :
        
        // Code that fills this.uniforms.
        this.uniforms = new Map();        
           :
           :
    }
}</code></pre>

    <p>Like what we have done before, we create an instance of <code>WebGLProgram</code> with the <a href="https://github.com/pkhungurn/cg-book-code/blob/c1e13b8f71d47ec0fac3fd6ed9313fa2cd71af27/chapter-14/program-01/src/program.js#L24"><code>createGlslProgram</code></a> function and save the return value in the <code>glObject</code> field. The <code>atttributes</code> and <code>uniforms</code> fields initially hold two new empty <code>Map</code>s. We shall discuss how the maps are filled in the next subsections.</p>

    <p>The <code>use</code> method is just a reimplementation of the <code>useProgram</code> function.</p>

<pre><code>use(code) {
  this.gl.useProgram(this.glObject);
  code();
  this.gl.useProgram(null);
}    
</code></pre>

    <p>With the explanation of the easy parts completed, let us discuss how we model vertex attributes and uniform variables.</p>

    <h3>14.1.4 &nbsp; Modeling vertex attributes</h3>

    <p>Our goal here is to create an object that represents each vertex attribute of a GLSL program so that we may have a nicer interface to work with. As a result, we need to extract information about vertex attributes from a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> object. The first bit of information we need is how many vertex attributes a program has. This can be objected using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getProgramParameter"><code>getProgramParameter</code></a> method of the WebGL context, passing the <code>WebGLProgram</code> instance and the contant <code>ACTIVE_ATTRIBUTES</code> as arguments. The method is used in the constructor of the <code>GlProgram</code> class as follows.</p>

<pre><code class="language-c">let numAttributes = gl.getProgramParameter(
  this.glObject, gl.ACTIVE_ATTRIBUTES);</code></pre>

    <p>WebGL refers to the vertex atrributes with integer indices from 0 to <code>numAttributes</code>-1, and it provides us a way to query information about a vertex attribute given its index. We shall use this mechanism inside the constructor of a <a href="https://github.com/pkhungurn/cg-book-code/blob/c1e13b8f71d47ec0fac3fd6ed9313fa2cd71af27/chapter-14/program-01/src/program.js#L59"><code>GlAttribute</code></a> object, which we create to model a vertex attribute. Before discussing the details of the class, let us see how the <code>GlAttribute</code> objects are instantiated.</p>

<pre><code class="language-c">this.attributes = new Map();
for (let index = 0; index &lt; numAttributes; index++) {
  let attribute = new GlAttribute(gl, this, index);
  this.attributes.set(attribute.name, attribute);
}</code></pre>

    <p>Here, we create field called <code>attributes</code> that is a Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a> which allows us to refer to vertex attributes by their names. We then loop through the indices of the vertex attributs and create an instance of <code>GlAttribute</code> for each of the index. The created will have a field called <code>name</code>, which we can use when we add the object to the map. Once the loop has finished running, we can use the <code>attributes</code> field to implement the <code>attribute</code> method of the <code>GlProgram</code> class that we discuss in the last section as follows.</p>

<pre><code class="language-c">attribute(name) {
  if (this.attributes.has(name)) {
    return this.attributes.get(name);
  } else {
    return null;
  }
}</code></pre>

    <p>Now, let us discuss the implementation of the <code>GlAttribute</code> object itself. The following is the its constructor.</p>

<pre><code class="language-c">export class GlAttribute {
  constructor(gl, program, index) {
    this.gl = gl;
    this.program = program;
    this.index = index;

    let info = gl.getActiveAttrib(program.glObject, index);
    this.name = info.name;
    this.size = info.size;
    this.type = info.type;
    this.location = gl.getAttribLocation(program.glObject, this.name);
    this.enabled = false;
  }

  :
  :
}</code></pre>

    <p>The constructor accepts three arguments: the WebGL context, the <code>GlProgram</code> object to which this <code>GlAttribute</code> object belongs, and lastly <code>the index</code> of the vertex attribute. The first three lines of the constructor saves the arguments as fields. The rest of the constructor extracts and saves information about the vertex attribute itself.</p>

    <p>First, we call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getActiveAttrib"><code>getAttiveAttrib</code></a> method of the WebGL context, passing the <code>WebGLProgram</code> instance stored in the <code>GlProgram</code> object and the index of the vertex attribute as arguments. The method would return the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLActiveInfo"><code>WebGLActiveInfo</code></a>, which has three fields.
    <ul>
      <li><code>name</code> is the name of the vertex attribute.</li>
      <li><code>size</code> is the "size" of the field. It is 1 if the field is not an array, and the number of elements in the array if the field is an array.</li>
      <li><code>type</code> is the data type of each of the component of the field. These are WebGL-specific constants such as <code>FLOAT</code>, <code>FLOAT_VEC2</code>, <code>FLOAT_VEC3</code>, <code>INT</code>, and <code>INT_VEC4</code>, and so on.</li>
    </ul>
    We then save these fields of the <code>WebGLActiveInfo</code> as fields of the <code>GlAttribute</code> instance.</p>

    <p>The next step is to retrieve the location of the vertex attribute. We have done this before in most programs in the previous chapters. However, this time, we do not specify the name of the vertex attribute ourselves but use the name we queried using the <code>glActiveInfo</code> method.</p>

    <p>Lastly, we initialize the <code>enabled</code> field to <code>false</code>. This field keeps track whether the vertex attribute has been enabled using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray"><code>enableVertexAttribArray</code></a> method or not.</p>

    <p>The class has two methods. The first is <code>setEnabled</code>, which we will not use directly most of the time.</p>

<pre><code class="language-c">setEnabled(enabled) {
    if (enabled) {
        this.gl.enableVertexAttribArray(this.location);
        this.enabled = true;
    } else {
        this.gl.glDisableVertexAttribArray(this.location);
        this.enabled = false;
    }
}</code></pre>

    <p>The argument <code>enabled</code> is a boolean that indicates whether the user wants to enable of disable the attribute. So, to enable, we call <code>enable(true)</code>, and, to disable, we call <code>enable(false)</code>. The other method is the <code>setup</code> method, which replaces the <code>setupVertexAttribute</code> function we have been using so far.</p>

<pre><code class="language-c">setup(buffer, size, stride, offset, type=null, normalized=false) {
  this.setEnabled(true);
  type = type || this.gl.FLOAT;
  let self = this;
  bindBuffer(this.gl, this.gl.ARRAY_BUFFER, buffer, () => {
    self.gl.vertexAttribPointer(
      self.location, size, type, normalized, stride, offset);
  });
}</code></pre>

    <p>With the <code>setup</code> method in place, we can succinctly setup vertex attributes as like we discussed in the last section.</p>

<pre><code class="language-c">self.program.attribute("vert_position")?.setup(
  self.vertexBuffer, 2, 4*5, 0);
self.program.attribute("vert_color")?.setup(
  self.vertexBuffer, 3, 4*5, 4*2);</code></pre>

    <h3>14.1.5 &nbsp; Modeling uniform variables</h3>

    <p>The next thing to do is to model uniform variables in the same way we did with vertex attributes. The process to do this starts in the constructor of the <code>GlProgram</code> class that we showed, in an incomplete from, in the last section. The following is the code that fills the <code>uniforms</code> map that associates uniforms with their names.</p>

<pre><code class="language-c">let numUniforms = gl.getProgramParameter(this.glObject, gl.ACTIVE_UNIFORMS);
this.uniforms = new Map();
for (let index = 0; index < numUniforms; index++) {
  let uniform = new GlUniform(gl, this, index);
  this.uniforms.set(uniform.name, uniform);
}</code></pre>

    <p>What we did here is similar to what we did in the last section. First, we find out how many uniform variables the program has, and this is done by calling the <code>getProgramParameter</code> method with the <code>ACTIVE_UNIFORMS</code> constant.</p>

<pre><code class="language-c">let numUniforms = gl.getProgramParameter(this.glObject, gl.ACTIVE_UNIFORMS);</code></pre>

    <p>Similar to vertex attributes, uniforms are indexed from $0$ to the number of uniforms minus one. Again, we iterate through the indices with the for loop and create a <code>GlUniform</code> object to represent the uniform with a given index. We then call the <code>set</code> method of the <code>Map</code> class to assiociate the newly created <code>GlUniform</code> object with the uniform's name.</p>

    <p>Let us now look at the <a href="https://github.com/pkhungurn/cg-book-code/blob/01178900bf69de740ff843914506ee030711cab6/chapter-14/program-01/src/program.js#L93"><code>GlUniform</code></a> class, which is also located in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01/src/program.js"><code>program.js</code></a> file. First, let us look at the constructor.</p>

<pre><code class="language-c">export class GlUniform {
  constructor(gl, program, index) {
    this.gl = gl;
    this.program = program;
    this.index = index;
    
    let info = gl.getActiveUniform(program.glObject, index);
    this.name = info.name;
    this.type = info.type;
    this.size = info.size;
    this.location = gl.getUniformLocation(program.glObject, this.name);
  }

  :
  :
}</code></pre>

    <p>Much like the constructor of <code>GlAttribute</code>, <code>GlUniform</code>'s is given the WebGL context, a <code>GlProgram</code> instance, and the index of the uniform. After saving the input arguments as fields, we proceed to get information about the uniform by calling the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getActiveUniform"><code>getActiveUniform</code></a> of the WebGL context, which is the uniform counterpart of the <code>glAtiveAttrib</code> method. The two method receives the same arguments (a <code>WebGLProgram</code> object and an index), and it returns the same thing (a <code>WebGLActiveInfo</code> object). We then proceed to save the information in the return value as fields. The last line of the constructor queries the location of the uniform using the name we fetched with <code>getActiveUniorm</code> method. Because a uniform does not require enabling like a vertex attribute, we do not need the <code>enabled</code> field like the <code>GlUniform</code> class.</p>

    <p>The <code>GlUniform</code> class has more methods than the <code>GlAttribute</code> class. This is because there are WebGL context methods such as <code>uniform1f</code>, <code>uniform2f</code>, and so on to wrap. In this chapter, we wrap 8 methods that are used to set vector types with float or integer components. We list some of the wrapping methods below and refer the reader to the code repository for the full listing.</p>

<pre><code class="language-c">export class GlUniform {
  :
  :

  set1Int(x) {
    this.gl.uniform1i(this.location, x);
  }

  set2Int(x, y) {
    this.gl.uniform2i(this.location, x, y);
  }
    
  :
  :

  set1Float(x) {
    this.gl.uniform1f(this.location, x);
  }

  set2Float(x, y) {
    this.gl.uniform2f(this.location, x, y);
  }
    
  :
  :
}</code></pre>

    <p>With the above methods, we can assign uniforms of a GLSL program as follows.</p>

<pre><code class="language-c">  self.program.uniform("center")?.set2Float(centerX, centerY);
self.program.uniform("scale")?.set1Float(scale);
</code></pre>

    <h3>14.1.6 &nbsp; Program 1</h3>

    <p><a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-14/program-01">Program 1</a> from the code repository contains a demonstration of how the abstractions in the last few sections are used. As we can see from the screenshots in Figure 14.1, the screen shows a square painted with a gradient of colors. The user can manipulate the position and the size of the square through through the sliders below the screen. This makes it quite similar to Program 2 from the last chapter in terms of what it shows and Program 4 (also from the same chapter) in terms of what the user can do with the UI.</p>

    <figure class="figure">
      <table>
        <tr>
          <td><a href="images/program-01-screenshot-00.png"><img src="images/program-01-screenshot-00.png" alt="" width="300"></a></td>
          <td><a href="images/program-01-screenshot-01.png"><img src="images/program-01-screenshot-01.png" alt="" width="300"></a></td>          
        </tr>        
      </table>
      <figcaption class="figure-caption"><strong>Figure 14.1</strong> Screenshots of Program 1.</figcaption>
    </figure>

    <p>However, Program 1 is different from all the programs we have seen so far because it displays information about the GLSL program being used to update the screen. In particular, there are two tables listing the vertex attributes and uniforms that the GLSL program has. We can show such information now precisely because we took time to create objects to represent these variables. </p>

    <p>If the reader is curious, they are welcome to read the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-01/src/index.js"><code>index.js</code></a> file to see how the shaders are implemented (not very different from the shaders from Chapter 13) and how we use the created <code>GlAttribute</code> and <code>GlUniform</code> objects to populate the tables (rather tedious and not very instructive). The main point of this section is <i>refactoring</i>: introducing a new way to do the same thing we did before so that we have a better foundation for more complex programs later.</p>


    <h2>14.2 &nbsp; An abstraction for colored meshes</h2>

    <p>Recall that a mesh is a collection of vertices that are connected to form a number of primitives. Operationally, all the meshes we have worked with so far are represented by two buffers. One is a buffer that holds vertex attributes, and we refer to this buffer as the "vertex buffer." The other stores the indices of vertices that are to be connected together, ad we refer to it as the "index buffer". In all previous programs, the buffers are specified independently, and there are no indications that they are parts of the same mesh. In this section, we introduce a new class that bundles the two buffers together so that there can be no confusion to which vertex buffer is to be used with with index buffer.</p>

    <h3>14.2.1 &nbsp; <code>PosColMesh</code></h3>

    <p>So far, all meshes we have worked with have at most two vertex attributes. The first is the 3D position of each vertex, which is mandatory. The second is the color of each vertex, which is optional. In later chapters, we will introduce more attributes such as the texture coordinates and the normal vector. However, in the next few chapters, we will only deal with vertex color. As a result, the new class represents colored meshes and is aptly called <code>PosColMesh</code>, where <code>Pos</code> stands for "position," and <code>Col</code> stands for "color." The source code for the class is available in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-02/src/pos-col-mesh.js"><code>pos-col-mesh.js</code></a> file in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-02/src"><code>chapter-14/program-02/src</code></a> directory of the book's code repository.</p>

    <p>Again, before going into how the class is implemented, let's see how it is used first. In previous programs, we intiialize the vertex and index buffer in a method called <code>createBuffers</code>, which is called by the <code>run</code> method, the entry point of our application. With the new class, we create a mesh instead of buffers, so the method is renamed to <code>createMesh</code>. Its <a href="https://github.com/pkhungurn/cg-book-code/blob/a40e4bdc1a9c3ce2f865e82013a1dd073ab13d5f/chapter-14/program-02/src/index.js#L47">source code</a> is reproduced below.</p>

<pre><code class="language-c">createMesh() {
  let meshBuilder = new PosColMeshBuilder(this.gl);
  
  meshBuilder
    .setColor(1.0, 1.0, 0.0, 1.0)
    .addVertex(-0.5, -0.5, 0.0)
    .setColor(0.0,  1.0, 1.0, 1.0)
    .addVertex(0.5, -0.5, 0.0)
    .setColor(1.0,  0.0, 1.0, 1.0)
    .addVertex(0.5, 0.5, 0.0)
    .setColor(1.0, 1.0, 1.0, 1.0)
    .addVertex(-0.5, 0.5, 0.0);
      
  meshBuilder
    .addIndices(0, 1, 2)
    .addIndices(0, 2, 3);

  this.mesh = meshBuilder.build();
}</code></pre>

    <p>The reader can see that we do no directly create the mesh. Instead, we create an instance of <a href="https://github.com/pkhungurn/cg-book-code/blob/05e4add205bba6ae76e14609900c2317a6929334/chapter-14/program-02/src/pos-col-mesh.js#L45"><code>PosColMeshBuilder</code></a>, a  class specifically designed to "build" <code>PosColMesh</code>. The class has methods such as <code>setColor</code>, <code>addVertex</code>, and <code>addIndices</code> that can be used to add information, piece by piece, to the mesh being built. After we have specified all the vertex and index data, we call the <code>build</code> method to get an instance of <code>PosColMesh</code>, which we keep as a field of the application class. For those who are familiar with object-oriented programming, this is an instance of the <a href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a> from the <a href="https://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>. </p>

    <p>The code becomes somewhat longer than those that we used to create buffers in previous programs. However, the author argues that it is much easier to read. Instead of seeing a bunch of numbers like in previous programs, we can easily read the vertex positions, the vertex colors, and the indices that make up the triangles from the code.</p>

    <p>It becomes easier to render the mesh using the new class. The relevent code in the <code>updateWebGL</code> method is as follows.</p>

<pre><code class="language-c">this.program.use(() => {
    self.program.uniform("center")?.set3Float(centerX, centerY, 0.0);
    self.program.uniform("scale")?.set1Float(scale);
    self.mesh.draw(self.program);
});</code></pre>

    <p>In previous programs, we need to use the vertex buffer to set up attribute variables. We also need to call <code>drawElements</code> with the index buffer to do the rendering. With the new class, all of these statements have been moved into the <code>draw</code> method of the <code>PosColMesh</code>, and so rendering becomes much simpler.</p>

    <h3>14.2.2 &nbsp; Implementation of <code>PosColMesh</code></h3>

    <p>Let's see how the <code>PosColMesh</code> class is implemented. It is located in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-02/src/pos-col-mesh.js"><code>pos-col-mesh.js</code></a> file in the <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-14/program-02/src"><code>chapter-14/program-2/src</code></a> directory of the book's code repository. The class itself is quite simple. It has a constructor, which is a little lengthy, and 3 short methods: <code>setupVertexAttributes</code>, <code>drawElements</code>, and <code>draw</code>. Most of the time, the only method we need to use is the last one, which draws the entire mesh, and t is implemented by calling the first two in succession. However, we expose these two methods so that the class's users can do more advanced things such as drawing the meshes multiple times after setting up the attribute variables once.</p>

    <p>Let us start with the constructor, whose code is reproduced below.</p>
  
<pre><code class="language-c">constructor(gl, positionData, colorData, indexData, primitiveType=null) {
  if (primitiveType === null) {
    primitiveType = gl.TRIANGLES;
  }

  if (primitiveType != gl.POINTS && primitiveType != gl.LINES && primitiveType != gl.TRIANGLES) {
    throw Error(`Primitive type ${primitiveType} is not supported.`);      
  }
    
  this.gl = gl;
  this.positionBuffer = createVertexBuffer(this.gl, new Float32Array(positionData));
  this.colorBuffer = createVertexBuffer(this.gl, new Float32Array(colorData));
  this.indexBuffer = createIndexBuffer(this.gl, new Int32Array(indexData));    
  
  this.numVertices = Math.floor(positionData.length / 3);
  this.numIndices = indexData.length;
}
</code></pre>

    <p>The constructor takes quite a number of parameters, which is not at all surprising for something as complicated as a colored mesh. As with almost all classes we created in this book, the first parameter <code>gl</code> is the WebGL context that we will use to issue WebGL commands. The next two parameters, <code>positionData</code> and <code>colorData</code>, are data that will constitute the vertex attributes, and they should be arrays of floating point numbers. We expect the length of <code>positionData</code> to be multiples of three because we want to represent 3D meshes. (Note though that we will work with 2D meshes almost exclusively in the next few chapters. However, we can think of a 2D mesh as a 3D mesh where the $z$-components of all vertices are the same.) We expect the length of <code>colorData</code> to be multiples of four because we would like to represent colors in the RGBA format. The <code>indexData</code> parameter should be a list containing vertex indices that we will used to form primitives. Lastly, we have the <code>primitiveType</code>, which should contain the WebGL constant that indicates the type of primitives that the mesh should be built from. The parameter has a default value of <code>null</code>, which the constructor would convert to <code>gl.TRIANGLES</code> immediately.</p>

<pre><code class='language-c'>if (primitiveType === null) {
  primitiveType = gl.TRIANGLES;
}</code></pre>

    <p>So, if the user does not specify a primitive type, the class would default to triangles. The next if statement in the constructor limits the allowed primitive types of only points, lines, and triangles for simplicity.</p>

    <p>The next four lines create assigns the main fields of the class. We save the WebGL context and then create three buffers: one for the vertex positions, one for the vertex colors, and one for the vertex indices.</p>

<pre><code class="language-c">this.gl = gl;
this.positionBuffer = createVertexBuffer(this.gl, new Float32Array(positionData));
this.colorBuffer = createVertexBuffer(this.gl, new Float32Array(colorData));
this.indexBuffer = createIndexBuffer(this.gl, new Int32Array(indexData));</code></pre>

    <p>The <code>createVertexBuffer</code> and <code>createIndexBuffer</code> methods are the same ones used in previous programs, and their sources are located in the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-02/src/vertex-index-buffer.js"><code>vertex-index-buffer.js</code></a> file. Lastly, we calculate the number of vertices and indices and save them as fields.</p>

<pre><code class="language-c">this.numVertices = Math.floor(positionData.length / 3);
this.numIndices = indexData.length;</code></pre>

    <p>Next, let's look at the <code>setupVertexAttributes</code> method. This method takes a <code>GlProgram</code> object and try to set up the attributes variables of the program with the position and color buffers.</p>

<pre><code class="language-c">setupVertexAttributes(program, 
    vertPositionName="vert_position", vertColorName="vert_color") {
  program.attribute(vertPositionName)?.setup(this.positionBuffer, 3, 4*3, 0);
  program.attribute(vertColorName)?.setup(this.colorBuffer, 4, 4*4, 0);
}
</code></pre>

    <p>Notice that the user can change the name of the attribute variables by specifying the <code>vertPositionName</code> and <code>vertPositionColor</code> parameters. However, for most of the programs in this book, we will use the default names <code>vert_color</code> and <code>vert_color</code>, so we will not need to specify the names when we use this method.</p>

    <p>The <code>drawElements</code> method is the wrapper of the <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-14/program-02/src/primitives.js"><code>drawElements</code></a> function that we have been using in the last programs. It basically provides the default values to the arguments so that, when the method is called with no arguments specified, all the primitives of the mesh is rendered.</p>

<pre><code class="language-c">drawElements(mode=null, count=null, offset=0) {
  if (mode === null) {
    mode = this.primitiveType;
  }
  if (count === null) {
    count = this.numIndices;
  }    
  drawElements(this.gl, this.indexBuffer, mode, count, offset);
}</code></pre>

    <p>Lastly, let us look at the <code>draw</code> method, which is basically calls the previous two methods in succession. In other words, in one step, it sets up the attribute variables to use the vertex buffers of the mesh, and then draws all the primitives.</p>

<pre><code class="language-c">draw(program, 
    vertPositionName="vert_position", 
    vertColorName="vert_color", 
    mode=null, count=null, offset=0) {
  this.setupVertexAttributes(program, vertPositionName, vertColorName);
  this.drawElements(mode, count, offset);
}</code></pre>

    <p>By specifying the parameters to values other than the default ones, the user can customizes the method calls to change the attribute variable names or to render the mesh partially.</p>
 
    <h3>14.2.3 &nbsp; Implementation of <code>PosColMeshBuilder</code></h3>

    <hr>
    <p>
      <a href="../chapter-13/index.html">&lt;&lt;</a>
      <a href="../index.html">Contents</a>      
    </p>
  </div>
  <script src="../js/bootstrap.bundle.min.js"></script>
  <script src="../js/littlefoot.js" type="application/javascript"></script>
  <script type="application/javascript">
    const { littlefoot } = require('littlefoot')
ou
    const lf = littlefoot({
      activateOnHover: true,
      hoverDelay: 250,
    });
  </script>
</body>

</html>