<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/theme.css" rel="stylesheet">
  <!-- MathJax -->
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        tags: "ams",
      },
      svg: {
        fontCache: 'global'
      },
    };
  </script>
  <script type="text/javascript" id="MathJax-script" src="../mathjax/tex-mml-chtml.js"></script>
  <link rel="stylesheet"
      href="../highlight/styles/default.min.css">
  <script src="../highlight/highlight.min.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script>
  hljs.highlightAll();
  hljs.initLineNumbersOnLoad();
  </script>
    
  <title>Chapter 9</title>
</head>

<body>
  <div class="container" style="max-width: 640px;">
    <span style="visibility: hidden;">
      \(
      \def\sc#1{\dosc#1\csod}
      \def\dosc#1#2\csod{{\rm #1{\small #2}}}

      \newcommand{\dee}{\mathrm{d}}
      \newcommand{\Dee}{\mathrm{D}}
      \newcommand{\In}{\mathrm{in}}
      \newcommand{\Out}{\mathrm{out}}
      \newcommand{\pdf}{\mathrm{pdf}}
      \newcommand{\Cov}{\mathrm{Cov}}
      \newcommand{\Var}{\mathrm{Var}}

      \newcommand{\ve}[1]{\mathbf{#1}}
      \newcommand{\mrm}[1]{\mathrm{#1}}
      \newcommand{\ves}[1]{\boldsymbol{#1}}
      \newcommand{\etal}{{et~al.}}
      \newcommand{\sphere}{\mathbb{S}^2}
      \newcommand{\modeint}{\mathcal{M}}
      \newcommand{\azimint}{\mathcal{N}}
      \newcommand{\ra}{\rightarrow}
      \newcommand{\mcal}[1]{\mathcal{#1}}
      \newcommand{\X}{\mathcal{X}}
      \newcommand{\Y}{\mathcal{Y}}
      \newcommand{\Z}{\mathcal{Z}}
      \newcommand{\x}{\mathbf{x}}
      \newcommand{\y}{\mathbf{y}}
      \newcommand{\z}{\mathbf{z}}
      \newcommand{\tr}{\mathrm{tr}}
      \newcommand{\sgn}{\mathrm{sgn}}
      \newcommand{\diag}{\mathrm{diag}}
      \newcommand{\Real}{\mathbb{R}}
      \newcommand{\sseq}{\subseteq}
      \newcommand{\ov}[1]{\overline{#1}}
      \DeclareMathOperator*{\argmax}{arg\,max}
      \DeclareMathOperator*{\argmin}{arg\,min}
      \)
    </span>
    
    <h1>9 &nbsp; Drawing primitives</h1>
    <hr>

    <p>We learned about the basics of WebGL programming in the last chapter, but all we could do was clearing the screen and limiting the area to which the clearing affects. To do more complicated things such as displaying a scene, we need to be able to draw primitives. (Recall <a href="../chapter-05.html#primtiives">Section 5.3</a>)</p>

    <p>One of the difficulties of learning WebGL is that drawing primitives is intertwined with another aspect of the library: writing GLSL programs. As mentioned <a href="../chapter-07/index.html#programs-and-shaders">Section 7.3.1</a>, we need to create a GLSL program before drawing a primitive. This process has many steps that would take some time to explain. Once it is done, we must also specify the vertices that make up the primitives that we want to draw and connections between them. This process also takes multiple steps as well.</p>

    <p>This chapter explains the above two processes. We first plunge ahead through the whole process  of creating and using GLSL programs without actually learning how to write them, leaving the details of GLSL programming as the subject of the next chapter. We then learn how to draw triangles. Next, we learn about the index buffer and how it can be used to alternatively specify triangles. We then learn how to draw two other types of primitives: lines and points. Lastly, we learn about viewports and how it can be used to specify the screen area over which primitives are drawn.</p>

    <h2>9.1 &nbsp; Program 1: Creating and using GLSL programs</h2>

    <p>The source code of the program is available in the <a href="http:/https://github.com/pkhungurn/cg-book-code/tree/main/chapter-09/program-01">chapter-09/program-01</a> directory of the source code repoository. Running it, you would see a black canvas and a combo box.</p>

    <figure class="figure">
      <a href="images/program-01-screenshot-00.png"><img src="images/program-01-screenshot-00.png" alt="" height="300"></a>
      <figcaption class="figure-caption"><strong>Figure 9.1</strong> A screenshot of Program 1 before any user interaction.</figcaption>
    </figure>

    <p>The combo box has three options that you can select: "program0," "program1," and "No program." When you select "program0" or "program1," a dialog box will pop up that tells you that the "program" has changed to the corresponding choice. When you select "No program," the dialog would say the application is not using any program.</p>

    <figure class="figure">
      <table cellpadding="5">
        <tr>
          <td><a href="images/program-01-screenshot-03.png"><img src="images/program-01-screenshot-03.png" alt="" height="200"></a></td>
          <td><a href="images/program-01-screenshot-01.png"><img src="images/program-01-screenshot-01.png" alt="" height="200"></a></td>
          <td><a href="images/program-01-screenshot-02.png"><img src="images/program-01-screenshot-02.png" alt="" height="200"></a></td>
        </tr>
        <tr>
          <td align="center">(a)</td>
          <td align="center">(b)</td>
          <td align="center">(c)</td>
        </tr>
      </table>
      <figcaption class="figure-caption"><strong>Figure 9.2</strong> The dialog that is shown when (a) "program0" is selected, (b) "program1" is selected, and "No program" is selected.</figcaption>
    </figure>

    <p>What happen under the hood is that, at any given time, a WebGL application either "use" a WebGL program or does not use any. Here, when a GLSL program is used, the graphics pipeline is customized according to what is written in the program's code. Our WebGL application starts up, it creates two WebGL programs called "program0" and "program1." It then immediately uses "program0," and it changes the program it uses according to the value of the combo box, which can be changed by the user. However, the application only uses the program, but it does not draw any primitives. So, we cannot see anything on the canvas at all. (We will start putting things on the canvas from Program 2 onward. Please be patient.)</p>

    <a name="#glsl-programs"></a>
    <h3>9.1.1 &nbsp; GLSL programs</h3>

    <p>As previously discussed in Chapter 7, A GLSL program in the context of WebGL 2.0 is made up of two shaders: a vertex shader and a fragment shaders. Program 1 has three shaders: a vertex shaders whose source code is in <a href="https:/https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-01/src/vertex-shader.vert"><code>vertex-shader.vert</code></a> and two fragment shaders whose source code is in <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-01/src/fragment-shader-0.frag"><code>fragment-shader-0.frag</code></a> and <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-01/src/fragment-shader-1.frag"><code>fragment-shader-1.frag</code></a>.  The two GLSL programs are created from the shaders as follows:</p>

    <table class="table table-bordered">
      <tr>
        <th>GLSL program</th>
        <th>Vertex shader</th>
        <th>Fragment shader</th>
      </tr>
      <tr>
        <td>program0</td>
        <td><code>vertex-shader.vert</code></td>
        <td><code>fragment-shader-0.frag</code></td>
      </tr>
      <tr>
        <td>program1</td>
        <td><code>vertex-shader.vert</code></td>
        <td><code>fragment-shader-1.frag</code></td>
      </tr>
    </table>      

    <a name="the-vertex-shader"></a>
    <h3>9.1.2 &nbsp; The vertex shader</h3>

    <p>Let us take a brief look at the vertex shader's source code. In this chapter, we would only read it to understand at a high-level what it does without worrying about the syntactic details.</p>

<figure class="figure">
<pre><code class="language-c">#version 300 es

in vec3 position;

void main() {
    gl_Position = vec4(position, 1);
}</code></pre>
<figcaption class="figure-caption"><strong>Listing 9.1</strong> The content of <code>vertex-shader.vert</code>.</figcaption>
</figure>


    <p>The source code looks syntactically similar to Javascript because it is written in GLSL, a language in the C family to which Javascript also belongs. The first line indicates that we are using GLSL version 3.00 ES, the latest version supported by WebGL 2.0. Similar to system program languages like C and C++, there is a function called <code>main</code> that serves as the "entry point:" it is the function that is run whenever the shader is run.</p> 
    
    <p>Recall from <a href="../chapter-07/index.html#vertex-shaders">Section 7.3.2</a> that a vertex shader must output clip space coordinates of the vertex being processed. The receiver of this value is the <code>gl_Position</code> variable, which is implicitly defined by the system. Because clip space coordinates have 4 components, the variable is of type <code>vec4</code>, which represents 4-component vectors.</p>

    <p>The shader's output is created by taking the value of the <code>position</code> variable and adding the number 1 at the end of it. Now, <code>position</code> is a global variable of type <code>vec3</code> that is declared with the "<code>in</code>" keyword, signifying that it is an input to the shader. While, in Program 1, we have not put any values in this variable yet, we will put vertex positions in it starting with Program 2.</p>

    <p>So, what the vertex shader does is simply copying the $xyz$-coordinates of vertex positions into the clip space coordinates whose $w$-component is always 1. Recall again from <a href="../chapter-07/index.html#vertex-shaders">Section 7.3.2</a> that the next step in the graphics pipeline after the vertex shader runs is the perspective divide, in which the NDCs are computed from the clip space coordinates by dividing the clip space $xyz$-coordinates with the $w$-coordinate. Because the $w$-coordinate is always 1, the NDCs would be equal to the vertex positions exactly. The vertex shader thus allows the user of the graphics pipeline to directly specify the NDCs. Because the $x$- and $y$-coordinates of the NDCs represent 2D positions on the canvas, this vertex shader sets up a 2D drawing system. We will see this in more details in other Programs in this chapter.</p>
    
    <a name="the-fragment-shaders"></a>
    <h3>9.1.3 &nbsp; The fragment shaders</h3>

    <p>Let us now turn our attention to the fragment shaders. They are even simpler than the vertex one.</p>

<figure class="figure">
<pre><code class="language-c">#version 300 es

precision highp float;

out vec4 fragColor;

void main() {
    fragColor = vec4(1.0, 1.0, 1.0, 1.0);
}</code></pre>
<figcaption class="figure-caption"><strong>Listing 9.2</strong> The content of <code>fragment-shader-0.frag</code>.</figcaption>
</figure>
      
<figure class="figure">
<pre><code class="language-c">#version 300 es

precision highp float;

out vec4 fragColor;

void main() {
    fragColor = vec4(0.0, 1.0, 0.0, 1.0);
}</code></pre>
<figcaption class="figure-caption"><strong>Listing 9.3</strong> The content of <code>fragment-shader-1.frag</code>.</figcaption>
</figure>

    <p>The two source files have the exact same structure. The first lines of both files indicate the GLSL version. Both have <code>main</code> functions, which serve as entry points like in the vertex shader. Both have the <code>precision highp float;</code> lines, which specify the number of bits used to represent values held by the <code>float</code> type. We will study the precise effect of this line later in <a href="../chapther-10/index.html">Chapter 10</a>, so let us not worry about it for now.</p>

    <p>We discussed earlier in <a href="../chapter-07/index.html#vertex-shaders">Section 7.3.2</a> that a fragment shader must decides whether to discard the fragment it process. If not, it must output the RGBA color of the fragment. The two fragment shaders above always does the latter. The receiver of the output value is the <code>fragColor</code> variable, which is a global variable declared with the keyward <code>out</code> to signify that it is the output. The first fragment shader always output the RGBA color $(1,1,1,1)$, which is white. The second fragment shader always output $(0,1,0,1)$, which is green. In other words, any primitives rendered by the two fragment shaders are white and green, respectively.</p>

    <p>As a result, program0, which is created from the vertex shader in <a href="#the-vertex-shader">Section 9.1.2</a> and the first fragment shader, would allow the user to directly specify the on-screen position of the vertices, and it would color all primitives white. On the other hand, program1 would do the same thing, but all primitives would be green instead.</p>
 
    <a name="how-to-create-shader"></a>
    <h3>9.1.4 &nbsp; How to create a GLSL shader</h3>

    <p>A GLSL program is made of a vertex shader and a fragment shader. Hence, in  order to create a program and render primitive with it, we must create shaders first. The process of creating a shader is encapsulated in the function <a href="https://github.com/pkhungurn/cg-book-code/blob/259193db086c5ead70be0fcc4bcf3c7975734a79/chapter-09/program-01/src/program.js#L1-L20"><code>createShader</code></a> in the <a href="https://github.com/pkhungurn/cg-book-code/blob/259193db086c5ead70be0fcc4bcf3c7975734a79/chapter-09/program-01/src/program.js#"><code>program.js</code></a> file. The code is reproduced in full below.</p>

    <figure class="figure">
<pre><code class="language-javascript">function createShader(gl, shaderType, sourceCode) {
  // Step 1: Create the shader.
  let shader = gl.createShader(shaderType);

  // Step 2: Set the shader source.
  gl.shaderSource(shader, sourceCode);

  // Step 3: Compile the shader.
  gl.compileShader(shader);

  // Step 4: Check for errors.
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      return shader;
  }

  // Step 5: Clean up if there are errors.
  let infoLog = gl.getShaderInfoLog(shader);
  gl.deleteShader(shader);
  throw new Error("An error occurred compiling the shader: " + infoLog);
}</code></pre>
    <figcaption class="figure-caption"><strong>Listing 9.4</strong> The <code>createShader</code> function.</figcaption>
    </figure>

    <p>The function has three arguments.</p>

    <ol>
      <li><code>gl</code> is the WebGL context we have been creating and using in all programs since the last chapter. We make it a a function argument instead of a global variable like in previous programs because this would allow us to put the <code>createShader</code> function in its own file without having to worry about how <code>gl</code> is obtained in <code>index.js</code>.</li>

      <li><code>shaderType</code> is a <code>GLenum</code> value that indicates the type of shader the we would like to create. It can be either <code>gl.VERTEX_SHADER</code> or <code>gl.FRAGMENT_SHADER</code>.</li>

      <li><code>sourceCode</code> is a string containing the source code of the shader. We will load the source code from the <code>.vert</code> and <code>.frag</code> files above, and we will discuss how to do this later.</li>
    </ol>

    <p>The process of creating a shader has four steps as indicated by the comments in the code. First, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createShader"><code>createShader</code></a> method of the WebGL context to create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLShader"><code>WebGLShader</code></a> object, which is used to represent a shader by the WebGL API. The method accepts a <code>GLenum</code> that indicates the type of the shader to which we just pass the <code>shaderType</code> variable.</p>

<pre><code class="language-javascript">let shader = gl.createShader(shaderType);</code></pre>

    <p>Second, we call the the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/shaderSource"><code>shaderSource</code></a> method of the WebGL context to set the source code of the newly created <code>WebGLShader</code> object.</p>

<pre><code class="language-javascript">gl.shaderSource(shader, sourceCode);</code></pre>

    <p>Third, we call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compileShader"><code>compileShader</code></a> method of the WebGL context. Here, compiling a shader turns the shader source code, which is human-readable text, into machine code that the GPU can understand and run.</p>

<pre><code class="language-javascript">gl.compileShader(shader);</code></pre>

    <p>Then, we check whether the compilation was successful or not. This is done retrieving the compilation state of the <code>WebGLShader</code> object with the WebGL context's <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getShaderParameter"><code>getShaderParameter</code></a> method, passing <code>gl.COMPILE_STATUS</code> as the second argument. If the compilation is successful, the method would return <code>true</code>. If this is the case, we can return the created <code>WebGLShader</code> object to the function's caller.</p>

<pre><code class="language-javascript">if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
  return shader.
}</code></pre>

    <p>If compilation fails, we want to inform the function's caller why it fails. This information is available in the shader's "information log," which we can retrived with the WebGL context's <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getShaderInfoLog"><code>getShaderInfoLog</code></a> method.</p>

<pre><code class="language-javascript">let infoLog = gl.getShaderInfoLog(shader);</code></pre>

    <p>Before we can inform the caller of the infomation log, we clean up the <code>WebGLShader</code> object, which is now cannot be used because of the failed compilation. Here, we delete it with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/deleteShader"><code>deleteShader</code></a> method in order to free resources occupied by the shader so far.</p>

<pre><code class="language-javascript">gl.deleteShader(shader);</code></pre>

    <p>Lastly, we throw a Javascript exception with a message created from the information log.</p>

<pre><code class="language-javascript">throw new Error("An error occurred compiling the shader: " + infoLog);</code></pre>

    <p>Compilation can fail because of various reasons, but the most significant would be syntax errors in the source code. Throwing the above exception is thus very important because it allows us, the programmer, to learn about our mistakes and rewrite the source code to fix them.</p>

    <h3>9.1.5 &nbsp; How to create a GLSL program</h3>

    <p>We now turn our attention to the process of creating a GLSL program, which is encapsulated in the <a href="https://github.com/pkhungurn/cg-book-code/blob/259193db086c5ead70be0fcc4bcf3c7975734a79/chapter-09/program-01/src/program.js#L1-L20#L24-L51"><code>createGlslProgram</code></a> function in <a href="https://github.com/pkhungurn/cg-book-code/blob/259193db086c5ead70be0fcc4bcf3c7975734a79/chapter-09/program-01/src/program.js#L1-L20#"></a><code>program.js</code></a>. This function creates a GLSL program from two pieces of source code, one for the vertex shader and another for the fragment shader. Its source code is reproduced below.</p>

    <figure class="figure">
<pre><code class="language-javascript">function createGlslProgram(gl, vertexShaderSource, fragmentShaderSource) {
  // Step 1: Create a program object.
  let program = gl.createProgram();

  // Step 2: Create an attach the shaders.
  let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  gl.attachShader(program, vertexShader);
  let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  gl.attachShader(program, fragmentShader);

  // Step 3: Link the program.
  gl.linkProgram(program);

  // Step 4: Validate the program.
  gl.validateProgram(program);

  // Step 5: Check for errors.
  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {        
      return program;
  }

  // Step 6: Clean up if there are errors.
  let infoLog = gl.getProgramInfoLog(program);
  gl.deleteProgram(program);
  gl.deleteShader(vertexShader);
  gl.deleteShaer(fragmentShader);
  throw new Error("An error occurred linking the program: " + infoLog);
}</code></pre>
      <figcaption class="figure-caption"><strong>Listing 9.5</strong> The <code>createGlslProgram</code> function.</figcaption>
    </figure>
    
    <p>The return value of this function is an instance of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a> object, which we create in Line 3 with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createProgram"><code>createProgram</code></a> method of the WebGL context.</p>

<pre><code class="language-javascript">let program = gl.createProgram();</code></pre>

    <p>After creating an instance, we need to specify a vertex shader and a fragment shader that are going to be used to make the program. This can be done with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/attachShader"><code>attachShader</code></a> method of the WebGL context. In Listing 9.5, we obtain the shaders by calling the <code>createShader</code> function with the appropriate arguments.</p>

<pre><code class="language-javascript">let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
gl.attachShader(program, vertexShader);
let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
gl.attachShader(program, fragmentShader);
</code></pre>

    <p>After the we have specified the shaders, we can "link" the program with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/linkProgram"><code>linkProgram</code></a>. Here, "linking" means combining the shaders to create a complete GLSL program.</p>

<pre><code class="language-javascript">gl.linkProgram(program);</code></pre>

    <p>If linking is successful, the creation process is complete, and we can start using the program immediately. However, like compiling a shader, linking can fail due to coding errors. It is good practice to check for them and report any problems to the user. To do so, we first call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/validateProgram"><code>validateProgram</code></a> of the WebGL context on the created program.</p>

<pre><code class="language-javascript">gl.validateProgram(program);</code></pre>

    <p>The next step would be to call the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getProgramParameter"><code>getProgramParameter</code></a> method on the program to get its link status: <code>gl.getProgramParameter(program, gl.LINK_STATUS)</code>. The return value is a boolean which is true if and only if linking was successful. If this is the case, we can return the created program and exit the function.</p>

<pre><code class="language-javascript">if (gl.getProgramParameter(program, gl.LINK_STATUS)) {        
  return program;
}</code></pre>

    <p>Note that the process to check for linking errors is a little more complicated than that to check for shader compiling errors. In Section <a href="#how-to-create-shader">9.1.4</a>, we can call <code>getShaderParameter</code> immediately after callling <code>compileShader</code>. However, in this section, we must call <code>validProgram</code> between tthe calls to <code>linkProgram</code> and <code>getProgramParameter</code>.</p>

    <p>Otherwise, we know that linking failed, and we need to fetch the error message and clean up the unused programs can shaders. Similar to what we did when compiling a shader, we can retrieve the error message with WebGL context's <code>getProgramInfoLog</code> method.</p>

<pre><code class="language-javascript">let infoLog = gl.getProgramInfoLog(program);</code></pre>

    <p>Deleting a program can then be done with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/deleteProgram"><code>deleteProgram</code></a>  method of the WebGL context. However, it is not enough to just delete the program here. We must also delete the shaders that we created earlier too.</p>    

<pre><code class="language-javascript">gl.deleteProgram(program);
gl.deleteShader(vertexShader);
gl.deleteShaer(fragmentShader);</code></pre>

    <p>Lastly, we throw an exception with the retrieved error message.</p>

<pre><code class="language-javascript">throw new Error("An error occurred linking the program: " + infoLog);</code></pre>

    <h3>9.1.6 &nbsp; Loading Source Code and Creating Programs from It</h3>

    <p>In the last section, we just discussed how to create a GLSL program if we have access to shader source code which is stored in Javascript strings. Now, we must figure out how get a hold of these strings. </p>
      
    <p>Recall from Section <a href="#the-vertex-shader">9.1.2</a> and <a href="#the-fragment-shaders">Section 9.1.3</a> that the source code is stored in three separte files: <code>vertex-shader.vert</code>, <code>fragment-shader-0.frag</code>, and <code>fragment-shader-1.frag</code>. When our WebGL program is served by a web server, these files will be available in the same directory as <code>index.html</code>. As a result, we need to read the files' contents and return them as strings. This is done with the <a href="https://github.com/pkhungurn/cg-book-code/blob/259193db086c5ead70be0fcc4bcf3c7975734a79/chapter-09/program-01/src/index.js#L4-L7"><code>loadText</code></a> function in the <a href="https://github.com/pkhungurn/cg-book-code/blob/259193db086c5ead70be0fcc4bcf3c7975734a79/chapter-09/program-01/src/index.js"><code>index.js</code></a> file, which uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">Fetch API</a> to do the job.</p> 

<pre><code class="language-c">async function loadText(url) {
  let fetchResult = await fetch(url);
  return fetchResult.text();
}</code></pre>

    <p>The two GLSL programs are created in the <code>createPrograms</code> function (not to be confused with the <code>createGlslProgram</code> function in the last section), whose code is reproduced in full below.</p>

<pre><code class="language-javascript">async function createPrograms(gl) {
  let vertexShaderSource = await loadText("vertex-shader.vert");
  let fragmentShader0Source = await loadText("fragment-shader-0.frag");
  let fragmentShader1Source = await loadText("fragment-shader-1.frag");

  let program0 = createGlslProgram(gl, vertexShaderSource, fragmentShader0Source);
  program0.name = "program0";

  let program1 = createGlslProgram(gl, vertexShaderSource, fragmentShader1Source);
  program1.name = "program1";

  return [program0, program1];
}</code></pre>

    <p>We see that we use the <code>loadText</code> function to retrieve the source code from the three files. Then, we use <code>createGlslProgram</code> to create two programs with the pairs of source code we discussed earlier in Section <a href="#glsl-programs">9.1.1</a>. The following two lines</p>

<pre><code class="language-javascript">    :
  program0.name = "program0";

    :
  program1.name = "program1";
</code></pre>

    <p>just add a field called <code>name</code> to the program objects so that we can use these names to identify the programs later. They are specific of the functionality of Program 1 and are not in any way a standard practice in WebGL programming. The function ends by returning the two programs inside a 2-element array.</p>    

    <h3>9.1.7 &nbsp; Using a Program</h3>

    <p>At any given time in the life of a WebGL application, there is at most one GLSL program that is being "used." When a program is used, its shaders are used to modified the relevant steps in the graphics pipeline, allowing for custom vertex and fragment processing. For example, all rendered primitives would be white and green when "program0" and "program1" are used, respectively.</p>

    <p>We can tell WebGL to start using a specific program with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/useProgram"><code>useProgram</code></a> method of the WebGL context. The method takes one argument, a <code>WebGLProgram</code> object to use.</p>
    
<pre><code class="language-javascript">gl.useProgram(&lt;program-object-to-use&gt;);</code></pre>    
    
    <p>We can also tell WebGL to not use any program (and therefore we would not be able to render any primtiives) by supplying <code>null</code> as the argument.</p>
    
    <pre><code class="language-javascript">gl.useProgram(null);</code></pre>

    <p>The GLSL program being used by WebGL is referred to as the "current program." It can be retrieved by getting the <code>CURRENT_PROGRAM</code> parameter of the WebGL context.</p>

<pre><code class="language-javascript">gl.getParameter(gl.CURRENT_PROGRAM)</code></pre>

    <h3>9.1.8 &nbsp; The Rest of Program 1</h3>

    <p>We have gone through everything about how to create GLSL programs and how to use them. In this section, we go through the rest of the code in <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-01/src/index.js"><code>index.js</code></a> and discuss how the whole program works.</p>

    <p>We start with the bottommost section of the file, which creates the WebGL context and sets up the drawing loop.</p>

<pre><code class="langauge-javascript">let lastProgram = null;

:
:
:

let canvas = $("#webglCanvas");

let gl = canvas[0].getContext("webgl2");
if (!gl) {
    alert("Cannot get WebGL 2 context!");
} else {
    createPrograms(gl).then(programs => {
        gl.useProgram(programs[0]);
        lastProgram = programs[0];
        window.requestAnimationFrame(() => updateWebGL(gl, programs));
    });    
}</code></pre>

    <p>First, we declare a variable called <code>lastProgram</code> to store the last program being used. This variable is only used for accounting as it allows the program to show an alert when the user changes the GLSL program. We will not need this variable again in next example programs.</p>

    <p>After successfully retrieving the WebGL context, we call <code>createPrograms</code> to create the two programs, which are returned in a 2-element array. We process the programs with a callback function given as the argument of the <code>then</code> method. The callback function immediately uses program0 and assigns it to the <code>lastProgram</code> variable. We then start the drawing loop by requesting the browser to run the <a href="https://github.com/pkhungurn/cg-book-code/blob/fad681ec78803150569f547a144b889a1d52fa25/chapter-09/program-01/src/index.js#L39-L55"><code>updateWebGL</code></a> function when the screen refreshes. The code of the function is reproduced in full below:

<pre><code class="language-javascript">function updateWebGL(gl, programs) {
  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  // Use the program.
  let programName = $("#programName").val();
  if (programName == "program0") {
      gl.useProgram(programs[0]);
  } else if (programName == "program1") {
      gl.useProgram(programs[1]);
  } else {
      gl.useProgram(null)
  }
  reportCurrentProgram(gl);

  window.requestAnimationFrame(() => updateWebGL(gl, programs));
}</code></pre>

    <p>The function sets the clear color to black and clears the screen, and this makes the canvas always black. The line <code class="language-javascript">let programName = $("#programName").val();</code> retrieves the choice the use makes with the combox box in the web page with the help of JQuery. Next, the if statement uses the program specified by the user. Then, the <code>reportCurrentProgram</code> function shows the appropriate alert when the program changes. The last statement continues the loop by requesting the <code>updateWebGL</code> function to be called again.</p>

    <p>Let us now look at the last unexplained piece, the <a href="https://github.com/pkhungurn/cg-book-code/blob/fad681ec78803150569f547a144b889a1d52fa25/chapter-09/program-01/src/index.js#L25-L37"><code>reportCurrentProgram</code></a> function.</p>

<pre><code class="language-javascript">function reportCurrentProgram(gl) {
  // Get the program being used.
  let currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);
  if (currentProgram != lastProgram) {
      if (!currentProgram) {
          alert("Currently not using any program.");
      } else {
          alert("Program changed to \"" + currentProgram.name + "\".");
      }

  }
  lastProgram = currentProgram;
}</code>
</pre>

    <p>We can see from the source code that the function retrieves the current program and checks whether it is the same as the <code>lastProgram</code>. If not, it shows an alert. Notice that it deals with the case where <code>lastProgram</code> is null (i.e., when no program is being used) differently. Lastly, it sets the <code>lastProgram</code> to the current program so that it correctly shows the right alert again when <code>reportCurrentProgram</code> is called.</p>

    <h2>9.2 &nbsp; Program 2: Drawing a triangle primitive</h2>
    
    <p>Now that we know how to create and use GLSL programs, we are ready to draw primitives. <a href="https://github.com/pkhungurn/cg-book-code/tree/main/chapter-09/program-02">Program 2</a> demonstrates how to draw a triangle primitive in the simplest possible way.</p>

    <figure class="figure">
      <a href="images/program-02-screenshot.png"><img src="images/program-02-screenshot.png" alt="" height="300"></a>
      <figcaption class="figure-caption"><strong>Figure 9.3</strong> A screenshot of Program 2.</figcaption>
    </figure>

    <p>Like creating a GLSL program, the process of drawing primitives also have multiple steps. The steps can be broken into two parts.</p>

    <ol>
      <li>Defining a buffer that hold vertex data. One can also optionally define another buffer that holds indices as well.</li>
      <li>Drawing the primitives using the defined buffers.</li>
    </ol>
    
    <a name="the-buffers"></a>
    <h3>9.2.1 &nbsp; The buffers</h3>

    <p>Recall from <a href="../chapter-05/index.html">Chapter 5</a> primtives are made of vertices, and each vertex has associated data such as its position, color, and normal. Because WebGL draws primitives using the GPU, we must download the vertice's data to the GPU first. This requires us to allocate a piece of GPU memory, which we shall call the <b>vertex buffer</b>, to store this data. Then, we must transfer the data to the GPU.</p>

    <p> Recall also that defining primitives requires information about connections between the vertices, and this information can be stored in an <b>index buffer</b>. Note that the index buffer in Chapter 5 is a Javascript array. However, if we want WebGL to use it, we must store the data that it holds in a buffer that resides in the GPU too. For simplicity, we shall refer to the piece of GPU memory that hold index data as an index buffer as well.</p>

    <p>Rendering primitives always require a vertex buffer, but an index buffer is optional. This is because WebGL allows connections between vertices to be defined implicitly as follows. If we want to draw 10 triangle primitives, we can create a vertex buffer that holds data for 30 different vertices. WebGL will then treat three consecutive vertices in this buffer as a traingle. This is the way of specifying connections that is used in Program 2, but we will use an index buffer to define connections explicity in Program 3.</p>

    <h3>9.2.2 &nbsp; Creating a vertex buffer</h3>

    <p>The following lines of code in Program 2's <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-02/src/index.js"><code>index.js</code></a> creates a vertex buffer.</p>

<pre><code class="language-javascript">let vertexData = new Float32Array([
  -0.5, -0.5, 0.0,
  0.5, -0.5, 0.0,
  0.5, 0.5, 0.0
]);
let vertexBuffer = createVertexBuffer(gl, vertexData);</code></pre>

    <p>First, we create a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Typed_arrays">Javascript typed array</a> to hold the vertex data. WebGL requires that data that are going to be transferred to a GPU buffer be stored in one of 4 different Javascript data types. In this book, we will use typed arrays because it is convenient and simple. Here, we use a typed array where each element is a 32-bit floating point number. The array has 9 elements, which can be divided into 3 different groups. Each group corresponds to a vertex and contains its $x$-, $y$- and $z$-coordinates. Because there are 3 vertices, we can draw exactly 1 triangle with this vertex buffer.</p>

    <p>Next, we pass the <code>vertexData</code> array to the <code>createVertexBuffer</code> function, whose code resides in another file: <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-02/src/vertex-buffer.js"><code>vertex-buffer.js</code></a>. We reproduce the function in full below.</p>

    <figure class="figure">
<pre><code class="language-javascript">function createVertexBuffer(gl, vertexData) {
  // Step 1: Create a buffer object.
  let vertexBuffer = gl.createBuffer();

  // Step 2: Bind the buffer to the ARRAY_BUFFER target.
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

  // Step 3: Transfer the vertex data to GPU.
  gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

  // Step 4: Unbind the buffer.
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // Step 5: Return the vertex buffer.
  return vertexBuffer;
}</code></pre>
      <figcaption class="figure-caption"><strong>Listing 9.6</strong> The <code>createVertexBuffer</code> function of Program 2.</figcaption>
    </figure>

    <p>The first step is to use the WebGL context's <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createBuffer"><code>createBuffer</code></a> method to create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer"><code>WebGLBuffer</code></a> object, which WebGL uses to represent a buffer in GPU memory.</p>

    <p>The second step is to "bind" the created buffer with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer"><code>bindBuffer</code></a> method. Here, "binding" means telling WebGL to "use" the specified buffer for the next buffer-related operations until the user specifies otherwise, much like using a GLSL program. However, while at most one program can be used at a time, multiple buffers can be bound simultaneously because WebGL keeps tracks of multiple buffers, each used for a different purpose. One can think of this as having multiple buffer "slots," where a slot corresponds to a purpose. Binding means filling the slot with a buffer that the user specifies. Confusingly, the library calls such a slot a "<b>target</b>." In this chapter, we will be using two targets that are indicated by the following <code>GLEnum</code> values:</p>

    <ul>
      <li><code>gl.ARRAY_BUFFER</code>: The target for a buffer that stores vertex attributes.</li>
      <li><code>gl.ELEMENT_ARRAY_BUFFER</code>: The target for a buffer that stores indices (i.e., the index buffer).</li>
    </ul>

    <p>The <code>bindBuffer</code> method has two arguments. The first is the <code>GLEnum</code> that indicates the target. The second is the buffer to bind to the target. In the code above, we immediately bind the created buffer to the <code>gl.ARRAY_BUFFER</code> target, indicating that we will use this buffer to store vertex attributes until we change our mind. The <code>gl.ELEMENT_ARRAY_BUFFER</code> target is not used in Program 2, but we will use it in Program 3.</p>

    <p>The third step is to download the vertex data given in the <code>vertexData</code> variable to the GPU. This is done with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData"><code>bufferData</code></a> method. The first argument to the method is a <code>GLEnum</code> which indicates the target buffer where the data are to be downloaded to. The second is the Javascript variable that holds the data. The third is another <code>GLEnum</code> that indicates the usage pattern of the data in the buffer, and WebGL will use this information to optimize how the data are stored. Here, the third argument is <code>gl.STATIC_DRAW</code>, which indicates that the data in the buffer is specified once and will not change. Moreover, it will be used multiple times by the application. The <code>GLEnum</code> is a perfect fit for what we want to do in Program 2 because the training we draw does not change, and we draw it once every frame.</p>

    <p>The fourth step is to "unbind" the buffer, which simply means to free the target the buffer is occupying after we are done with it. This can be done by calling <code>bindBuffer</code> with <code>null</code> as the buffer to be bound. This step is optional because the bound buffer would change once we call <code>bindBuffer</code> with a diferent buffer object. However, we include this step for hygienic purpose: we assume that the <code>gl.ARRAY_BUFFER</code> target is not bound to anything before <code>createVertexBuffer</code> is called, and we want to leave the target in the same state when the function returns.</p>

    <p>Lastly, we return the created buffer as the return value of the function.</p>
    
    <a name="drawing-primitives"></a>
    <h3>9.2.3 &nbsp; Drawing primitives</h3>

    <p>Naturally, the code that draws primitives must be invoked every time we update the screen, so it belongs inside the <a href="https://github.com/pkhungurn/cg-book-code/blob/68616f4575e296b6620ab9f4e3281e7ed7168abb/chapter-09/program-02/src/index.js#L16-L41"><code>updateWebGL</code></a> function. However, before delving into the details of the function, let us see first how the function is used in the overall program. This can be seen in the lines of code below.</p>

<pre><code class="language-javascript">let vertexData = new Float32Array([
    -0.5, -0.5, 0.0,
    0.5, -0.5, 0.0,
    0.5, 0.5, 0.0
]);
let vertexBuffer = createVertexBuffer(gl, vertexData);

createProgram(gl).then(program => {
    windows.requestAnimationFrame(() => updateWebGL(gl, program, vertexBuffer));
});</code></pre>

    <p>We note earlier that drawing a primitive requires a GLSL program, so we must create one before anything can be drawn. In the above code, this is done with the <a href="https://github.com/pkhungurn/cg-book-code/blob/afde72cc9d05ddb3e1f2ec5a37a0c6ba3d8c6aa9/chapter-09/program-02/src/index.js#L10-L14"><code>createProgram</code></a> function, which is almost the same as the <code>createPrograms</code> function of Program 1, except that it only creates and returns one program. The vertex shader's source is in <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-02/src/vertex-shader.vert"><code>vertex-shader.vert</code></a>, which is a copy of the same file in Program 1. The fragment shader's source is in <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-02/src/fragment-shader.frag">fragment-shader.frag</a>, which is a copy of Program 1's <a href="https://github.com/pkhungurn/cg-book-code/blob/main/chapter-09/program-01/src/fragment-shader-0.frag"><code>fragment-shader-0.frag</code></a>. As explained earlier, the GLSL program made of these two shaders would allow its user to directly specify the screen positions of the vertices, and all rendered primitives would be white.</p>

    <p>In addition to a GLSL program, we also need a buffer containing vertex data, and we will use the vertex buffer whose creation as described in the last section. As a result, Program 2's <code>updateWebGL</code> function takes 3 arguments: the WebGL context, a program, and a vertex buffer. Let us now looks at its source code.</p>

    <figure class="figure">
<pre><code class="language-javascript">function updateWebGL(gl, program, vertexBuffer) {
  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // *******************************
  // * Drawing triangle primitives *
  // *******************************
  // Step 1: Use the program.
  gl.useProgram(program);
  // Step 2: Get location of the attribute we want to assign with the data from the vertex buffer.
  let positionLocation = gl.getAttribLocation(program, "position");
  // Step 3: Enable the attribute.
  gl.enableVertexAttribArray(positionLocation);
  // Step 4: Bind the buffer we want to use.
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  // Step 5: Assign the attribute to the bound buffer.
  gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3 * 4, 0);
  // Step 6: Unbind the buffer.
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  // Step 7: Draw.
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  // Step 8: Unuse the program.
  gl.useProgram(null);

  window.requestAnimationFrame(() => updateWebGL(gl, program, vertexBuffer));
}</code></pre>
      <figcaption class="figure-caption"><strong>Listing 9.7</strong> The <code>updateWebGL</code> function of Program 2.</figcaption>
    </figure>

    <p>As usual, the function starts with clearing the screen and ends with requesting that itself be run again when the screen updates the next time. The main difference between this function and those of other programs is the multi-step process to render a primitive.</p>

    <p>Before rendering a primitive, we must make sure that the GLSL program that processes the vertices and the fragments is used by WebGL. So, Step 1 of the process is using a program, and this is paired with Step 8, which unuses it.</p>

    <p>Next, we need to specify how the program would access the vertex data that we have prepared. More simply, we need to tell WebGL which variables in the programs are going to get what portion of the vertex data. This specification is done in Step 2 to Step 6. These 5 steps can be divided into two stages.</p>

    <ul>
      <li>The first stage consists of Step 2 and Step 3. In this stage, we identify the variables that are to receive vertex data and "enable" them.</li>

      <li>The second stage consists steps from Step 4 to Step 6. We specify the portion of the vertex buffer that are going to be stored into the variables we selected.</li>
    </ul>

    <h4>9.2.3.1 &nbsp; Identifying and enabling attribute variables</h4>

    <p>There are a number of special types of variables in WebGL. One type of these special variables is called <b>attribute variables</b>. These are global variables in a vertex shader that are marked with the keyword <code>in</code>. These variables are called "attribute" variables because they are mainly used to store vertex attributes. The vertex shader of Program 2 has one attribute variable called <code>position</code>, and it was declared as follows:</p>

<pre><code class="language-c">in vec3 position;</code></pre>

    <p>We see that the variable has type <code>vec3</code>, which means that the variable is used to store 3-component vectors. The variable name implies that these 3-vectors are 3D positions of the vertices.</p>

    <p>When WebGL compiles a vertex shader, it assigns a unique integer called a <b>location</b> to each attribute variable. This number can be used later in Javascript code to refer to particular variables that we are interested in. In our case, we need to know the location of the <code>position</code> variable because we want to connect it to the vertex buffer. The location of an attribue variable can be retrieved using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getAttribLocation"><code>getAttribLocation</code></a> method of the WebGL context. The method is used in the source code of Program 2 as follows:</p>

<pre><code class="language-javascript">// Step 2: Get location of the attribute we want to assign with the data from the vertex buffer.
let positionLocation = gl.getAttribLocation(program, "position");</code></pre>

    <p>As we can see, the method takes two arguments. The first is the program, and the second is a string whose content is the name of the variable. Because the location will be used multiple times later, we store it in the variable <code>positionLocation</code> for convenience.</p>

    <p>All attribute variables in a vertex shader are "disabled" by default. A disabled variable cannot be used inside a vertex shader because we cannot tell what values the variable would take when the vertex shader is executed. Thus, after an attribute variable's location, we should "enable" the variable immediately. This can be done with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray"><code>enableVertexAttribArray</code></a> method of the WebGL context as follows:</p>

<pre><code class="language-javascript">// Step 3: Enable the attribute.
gl.enableVertexAttribArray(positionLocation);</code></pre>

    <h4>9.2.3.2 &nbsp; Specifying vertex attribute data</h4>

    <p>After identifying and enabling the attribute variable we would like to use, we need to specify what data these variables would receive. More comcretely, we have a number of vertex buffers that store vertex data, and we must let WebGL know which part of which vertex buffer would be streamed to which attribute variable.</p>

    <p>Before we can do the above, we need to bind a vertex buffer that the attribute variable would take data from. This is done in Step 4 of Listing 9.7, and we use the same <code>gl.bindBuffer</code> method as in Section 9.2.2. Step 4 is paired with Step 6 where we unbind the buffer for programming hygiene.</p>

    <p>The most complicated step in this stage is Step 5 where we use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer"><code>vertexAttribPointer</code></a> method of the WebGL context to connect the vertex data to the attribute variable.</p>

<pre><code class="language-javascript">// Step 5: Assign the attribute to the bound buffer.
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3 * 4, 0);</code></pre>

    <p>The method has 6 parameters.</p>

    <p>The first parameter is the location of the variable we would like to use. In our case, this is the location of the <code>position</code> attribute variable that we have saved in the <code>positionLocation</code> variable.</p>

    <p>The second parameter is the number of components of the attribute variable. Because the <code>position</code> attribute variable is a <code>vec3</code>, it represents a vector with 3 components. So, the value of the parameter is naturally 3. By the same logic, the parameter would be 2 if the atttribute variable has type <code>vec2</code> and 4 if the attribute variable has type <code>vec4</code>. We will learn more about these GLSL types in the next chapter.</p>

    <p>The third parameter is the <code>GLenum</code> which represents the type of the elements of the vertex buffer. Because we prepared our vertex buffer with a <code>Float32Array</code>, the parameter value would be <code>gl.FLOAT</code>. (In fact, the value would be <code>gl.FLOAT</code> most of the times in the rest of the book.) On the other hand, if we created the vertex buffer with an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array"><code>Int32Array</code></a>, the parameter value would be <code>gl.INT</code>.</p>

    <p>The fourth parameter is a boolean value. If <code>true</code>, WebGL would "normalize" the data before storing it into the attribute variable. This normalization only happends when the attribute variable store floating point values, but the vertex buffer stores integer values. (Note: This is not the same as vector normalization in Section <a href="../chapter-03/index.html#scaling">3.5.1</a>.) The parameter has not effect otherwise. Because each component of <code>vec3</code> stores a floating point number and our buffer also stores floating point numbers, the parameter has no effect. We arbitrarily leave it as <code>false</code>. (In fact, we will set this variable to <code>false</code> for the rest of this book.)</p>

    <p>The fifth parameter is an integer called the <b>stride</b>. It is the distance in bytes between one instance of the vertex attribute value and the next instance in the vertex buffer. The best way to think about this to think of the vertex buffer as an <i>interleaved buffer</i> (Section <a href="../chapter-05/index.html#point-clouds">5.2</a>). An interleaved buffer is divided into contiguous blocks where each block stores multiple attributes of a vertex, and each block has the same size in bytes. The stride here would be the size of each such block. In our case, we set the parameter value to <code>3*4</code>, which is equal to 12. This is because, for our vertex buffer, each vertex has only one parameter: the position. A position is a vector with 3 components, and each component is stored as a floating-point number in the vertex buffer. As a floating-point number is 4 bytes in size, each block in the vertex buffer has $3 \times 4 = 12$ bytes.</p>

    <p>The sixth parameter is another integer, and it is called the <b>offset</b>. It is the number of bytes from the start of the interleaved buffer block to the start of the data of the vertex attribute in question. In our case, the offset is 0 because our attribution, the position, is already at the start of the block. The offset will be non-zero for attributes that are not the first one in the interleaved buffer, and we will see this in the next chapters. A good sanity check for the value of the offset is that it must be at least 0 and must also be less than the stride.</p>
    
    <p>Once we have specified the data that will fill the attribute variable, we can unbind the vertex buffer like in Step 6 of the code.</p>

    <h3>9.2.3.3 &nbsp; Drawing</h3>

    <p>Step 7 draws the primitive with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays"><code>drawArrays</code></a> method of the WebGL context.</p>

<pre><code class="language-javascript">// Step 7: Draw.
gl.drawArrays(gl.TRIANGLES, 0, 3);</code></pre>

    <p>The arguments to the method, expecially the the numbers 0 and 3, are rather cryptic. So let's look at them one by one.</p>

    <p>The first parameter is the <code>GLEnum</code> that indicates the primitive type we want to draw. You can see all the possible values by looking at the table in <a href="../chapter-05/index.html#primitives">Section 5.3</a>. Because we want to draw a triangle, we specify <code>gl.TRIANGLEs</code>.</p>

    <p>The second parameter is called <code>first</code>. It is the zero-based index of the first vertex in the vertex buffer that we wish to use to draw the primitive(s). The third parameter is called <code>count</code>, and it is the number of vertices from that indexed by <code>first</code> that we want to use in drawing. Hence, <code>drawArrays</code> tells WebGL to use a contiguous chuck of the vertex buffer to draw the primitives specified in the first argument.</p>

    <p>In our case, our vertex buffer has only 3 vertices, which can make exactly one triangle. We thus set <code>first</code> to 0, which is the index of the first vertex, and <code>count</code> to 3, which is the number of all vertices. If the vertex buffer stores more than one triangle primitives, we can choose draw any set of consecutive triangles in the buffer by setting these two variables appropriately.</p>

    <p>It is important to note that <code>count</code> must be consistent with the type of primitive to be drawn. When we draw triangles, <code>count</code> should be divisible by 3. When we draw line segments, <code>count</code> should be divisible by 2. For points, <code>count</code> can be any non-negative number.</p>

    <p>We have gone through a lot of steps in order to just draw a single triangle. This shows us that 3D rendering requires much preparation. As a recap, let us list what are required before we call <code>drawArrays</code>.</p>

    <ul>
      <li>We must have prepared a GLSL program and used it.</li>
      <li>We must locate all the attribute variables in the GLSL program and enable them.</li>
      <li>We must have prepared a vertex buffer and connect it to the attribute variables in the GLSL program.</li>
    </ul>

    <p>Again, after we are done with drawing primitives, we should clean up by unusing the program, and this is done in Step 8.</p>

    <h2>9.3 &nbsp; Program 3: Drawing triangle primitives using an index buffer</h2>

    <p>Program 2 draws a triangle primitive using only a vertex buffer. As mentioned in <a href="index.html#the-buffers">Section 9.2.1</a>, connection between vertices is defined explicitly: we must prepare the buffer so that each three consecutive vertices in it contain vertex positions of triangles. This can be wasteful when multiple triangles share the same vertices because the data of those vertices must be repeated multiple times.</p>

    <figure class="figure">
      <figcaption class="figure-caption"><strong>Figure 9.4</strong> A mesh where mutliple triangles share the same vertex, and the corresponding vertex buffer. Notice that the data of Vertex 0 is repeated multiple times in the vertex buffer. <b>TODO: Draw this figure.</b></figcaption>
    </figure>

    <p>The wastefulness program can be mitigated by using an index buffer, which stores indices of vertices in the vertex buffer in the order that from primitives. This representation is much more economical because (1) we can store vertex data with no redundancy, and (2) when a vertex is used multiple times, we only need to repeat its index instead of all vertex's data.</p>

    <figure class="figure">
      <figcaption class="figure-caption"><strong>Figure 9.5</strong> The same mesh as that in Figure 9.4. However, this time the mesh is represented by a vertex buffer and an index buffer. We can see that the vertex buffer contains no repetition, and the index buffer is much smaller than the vertex buffer in Figure 9.4. <b>TODO: Draw this figure.</b></figcaption>
    </figure>

    <p>WebGL supports representing meshes with index buffers, and Program 3 uses one to draw a mesh containing two triangles that share vertices with each other. Below is a screenshot of the program, which shows a white square.</p>

    <figure class="figure">
      <a href="images/program-03-screenshot.png"><img src="images/program-03-screenshot.png" alt="" height="300"></a>
      <figcaption class="figure-caption"><strong>Figure 9.6</strong> A screenshot of Program 3.</b></figcaption>
    </figure>

    <h3>9.3.1 &nbsp; Creating an index buffer</h3>

    <p>Program 3's source code is mostly the same as that of Program 2. One of the main difference is that Program 3 has one more file called <code>index-buffer.js</code>. It contains a function called <code>createIndexBuffer</code>, which, as the name implies, is used to create an index buffer to represent a mesh. Again, before we take a look at the function, we shall see how it is used in the main program.</p>        

<pre><code class="language-javascript">// **************************
// * Creating vertex buffer *
// **************************    
let vertexData = new Float32Array([
    -0.5, -0.5, 0.0,
    0.5, -0.5, 0.0,
    0.5, 0.5, 0.0,
    -0.5, 0.5, 0.0
]);
let vertexBuffer = createVertexBuffer(gl, vertexData);

// *************************
// * Creating index buffer *
// *************************    
let indexData = new Int32Array([
    0, 1, 2,
    0, 2, 3
]);
let indexBuffer = createIndexBuffer(gl, indexData);

createProgram(gl).then(program => updateWebGL(
  gl, program, vertexBuffer, indexBuffer));</code></pre>

    <p>Like in Program 2, we first create a vertex buffer to store vertex data. This time, though, our vertex buffer has 12 elements instead of 9 because now we want to draw a square, which has 4 vertices.</p>

    <p>The main difference between Program 2 and Program 3 is the creation of the index buffer. Similar to a vertex buffer, we can store the data that are going to be stored in an index buffer can be stored in 4 Javascript, and we have chosen to use a typed array. However, we use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array"><code>Int32Array</code></a> instead of a <code>Float32Array</code> because each element of an inde buffer is an integer, not a floating point number like vertex coordinates.</p>

    <p>The type array that contains the index data has 6 elements because we will draw a square that is made up of 2 triangles. The first triangle is made of vertices whose indices are 0, 1, and 2, and they form a right triangle whose right angle is the bottom left corner of the square. The second triangle's indices are 0, 2, and 3, and it is a right triangle whose right angle is the top left corner of the square. Notice that the indices are ordered so that the vertices swirl in the counterclockwise direction, following the convention that a counterclockwise swirl signifies the front face (<a href="../chapter-06/index.html#face-normal-vectors">Section 6.2</a>).</p>

    <p>Now, let us look at the <code>createIndexBuffer</code> function in the <a href="https://github.com/pkhungurn/cg-book-code/blob/bc1b577a41fa4304dd888b9f7a67c698dfd0ca8e/chapter-09/program-03/src/index-buffer.js#L1"><code>index-buffer.js</code></a> file.</p>

<pre><code class="language-javascript">function createIndexBuffer(gl, indexData) {
  // Step 1: Create a buffer object.
  let indexBuffer = gl.createBuffer();

  // Step 2: Bind the buffer to the ELEMENT_ARRAY_BUFFER target.
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

  // Step 3: Transfer the buffer data.
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);

  // Step 4: Unbind the buffer.
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  // Step 5: Return the buffer.
  return indexBuffer;
}</code></pre>

    <p>We see that the <code>createIndexBuffer</code> function is very similar to the <code>createIndexBuffer</code> function. It has the same number of steps, and the steps use exactly the same methods of the WebGL context. The only difference is that the <code>GLEnum</code> that is used with the <code>glBindBuffer</code> and <code>glBufferData</code> methods are now <code>gl.ELEMENT_ARRAY_BUFFER</code> instead of <code>gl.ARRAY_BUFFER</code>.</p>

    <h3>9.3.2 &nbsp; Using the index buffer</h3>

    <p>The index buffer created above is used in the <a href="https://github.com/pkhungurn/cg-book-code/blob/bc1b577a41fa4304dd888b9f7a67c698dfd0ca8e/chapter-09/program-03/src/index.js#L17-L46"><code>updateWebGL</code></a> function. Its source code is reproduced below.</p>

<pre><code class="language-javascript">function updateWebGL(gl, program, vertexBuffer, indexBuffer) {
  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // *****************************************************
  // * Drawing triangle primitives using an index buffer *
  // *****************************************************
  // Step 1: Use the program.
  gl.useProgram(program);
  // Step 2: Get location of the attribute we want to assign with the data from the vertex buffer.
  let positionLocation = gl.getAttribLocation(program, "position");
  // Step 3: Enable the attribute.
  gl.enableVertexAttribArray(positionLocation);
  // Step 4: Bind the buffer we want to use.
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  // Step 5: Assign the attribute to the bound buffer.
  gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 3 * 4, 0);
  // Step 6: Unbind the buffer.
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  // Step 7: Bind the index buffer.
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  // Step 8: Draw with drawElements.
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0);
  // Step 9: Unbind the indexbuffer.
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  // Step 10: Unuse the program.
  gl.useProgram(null);

  window.requestAnimationFrame(() => updateWebGL(gl, program, vertexBuffer, indexBuffer));
}</code></pre>

    <p>The function is a little more that that of the Program 2. It has an extra parameter, <code>indexBuffer</code>. It also has a few more steps, but the structure is mostly the same. We first need to use the GLSL program in Step 1 and then unuse it in the last step. (The GLSL program being used here is exactly the same as the one in Program 2.) Once we use the program, we find the location of the attribute variable that will receive the vertex position data in Step 2 and enable it in Step 3. We then specify the data that will go into the attribute variable in Step 5, 6, and 7 in the exact manner discussed in Section <a href="#drawing-primitives">9.2.3</a>.</p>

    <p>However, drawing is now done differently. In Program 2, this is accomplicated by one call to the <code>drawArrays</code> method, but now we use three statements.  In the first statement, we bind the index buffer to the <code>gl.ELEMENT_ARRAY_BUFFER</code> slot, indicating that we will be using the index buffer.</p>

<pre><code class="language-javascript">// Step 7: Bind the index buffer.
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);</code></pre>

    Then, we draw the primitives with a different method, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements"><code>drawElements</code></a> as follows.

<pre><code class="language-javascript">// Step 8: Draw with drawElements.
gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0);</code></pre>

    <p>The method is simpler than <code>drawArrays</code> because it has fewer arguments.</p>

    <ul>
      <li>The first argument is the type of primitive we want to draw, which is <code>gl.TRIANGLES</code> in our case.</li>
      <li>The second argument is the number of indices in the index buffer that we would like to use. Because we want to use every index in it, we set the argument to 6.</li>
      <li>The third argument is the data type of each index in the index buffer. Its value can either be <code>gl.UNSIGNED_BYTE</code>, <code>gl.UNSIGNED_SHORT</code>, and <code>gl.UNSIGNED_INT</code>. They indicate that an index takes 1 byte, 2 bytes, and 4 bytes, respectively. In our case, we created our index buffer with an <code>Int32Array</code> where each element has 4 bytes, so we have to use <code>gl.UNSIGNED_INT</code>.</li>
      <li>The last argument is called <code>offset</code>, and it is the index of the first index in the buffer that we would like to use. We set the value to 0, indicating that we want to start from the very first index.</li>
    </ul>
    
    <p>For the rest of the book, we will be drawing primitives using both the vertex buffer and the index buffer instead of just using the vertex buffer alone. Let us review what is required to draw primitives with an index buffer with <code>drawElements</code> before we move on to the next section.</p>

    <ul>
      <li>We must have prepared a GLSL program and used it.</li>
      <li>We must locate all the attribute variables in the GLSL program and enable them.</li>
      <li>We must have prepared a vertex buffer and connect it to the attribute variables in the GLSL program.</li>
      <li>We must bind the index buffer to the <code>gl.ELEMENT_ARRAY_BUFFER</code> slot before calling <code>drawElements</code> and <b>leave the index buffer bound</b>.</li>
      <li>We can then call <code>drawElements</code> to carry out the drawing.</li>
      <li>Afterwards, we must unbind the index buffer and unuse the program for hygiene.</li>
    </ul>


    <h2>9.4 &nbsp; Program 4: Drawing line primitives</h2>

    <h2>9.5 &nbsp; Program 5: Drawing point primitives</h2>    

    <h2>9.6 &nbsp; Program 6: Specifying viewports</h2>
     
    <hr>
    <div class="footnotes">
    </div>

    <hr>
    <p>
      <a href="../chapter-08/index.html">&lt;&lt;</a>
      <a href="../index.html">Contents</a>
      <a href="../chapter-10/index.html">&gt;&gt;</a>
    </p>
  </div>
  <script src="../js/bootstrap.bundle.min.js"></script>
  <script src="../js/littlefoot.js" type="application/javascript"></script>
  <script type="application/javascript">
    const { littlefoot } = require('littlefoot')

    const lf = littlefoot({
      activateOnHover: true,
      hoverDelay: 250,
    });
  </script>
</body>

</html>